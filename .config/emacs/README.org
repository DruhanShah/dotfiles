#+title: Druhan's Emacs Configuration
#+author: Druhan Shah

#+startup: overview
#+property: header-args :tangle init.el
#+auto_tangle: t

This configuration is heavily based off of [[https://github.com/rougier][Nicolas Rougier]]'s emacs packages and ideas. All the packages taken more or less verbatim from Mr. Rougier's repositories are in the =nano/= directory and any other configuration files are in the =not-nano/= directory.

This is a literate configuration, which means all the code blocks in this Org file will be exported using Org-Babel's tangle feature into their corresponding config files on save. As a result, all the configuration necessary will be in this file as far as possible. Sometime in the future, a Table of Contents will be implemented to make navigating this document easier.

* Preambles 

The Early-Init file is executed before =init.el=, and hence is where we disable =package.el= in favour of Elpaca.

#+begin_src emacs-lisp :tangle early-init.el
  ;; Early-init file, executed before init.el when starting Emacs

  (setq package-enable-at-startup nil)
#+end_src

Now, we throw in a preamble comment in the Init file just in case someone reads it before this README :P

#+begin_src emacs-lisp
  ;; ---------------------------------------------
  ;;              EMACS INIT FILE
  ;; 
  ;; This is where all of my configuration for
  ;; GNU Emacs resides. Please read README.org for
  ;; more detailed information about the config.
  ;; ---------------------------------------------
#+end_src


* Package Manager (Elpaca)

This codeblock is directly from the Elpaca repository's README. I have only added a final expression integrating Elpaca with ~use-package~.

#+begin_src emacs-lisp
  (defvar elpaca-installer-version 0.11)
  (defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
  (defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
  (defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
  (defvar elpaca-order
    '(elpaca :repo "https://github.com/progfolio/elpaca.git"
             :ref nil :depth 1 :inherit ignore
             :files (:defaults "elpaca-test.el" (:exclude "extensions"))
             :build (:not elpaca--activate-package)))
  (let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
         (build (expand-file-name "elpaca/" elpaca-builds-directory))
         (order (cdr elpaca-order))
         (default-directory repo))
    (add-to-list 'load-path (if (file-exists-p build) build repo))
    (unless (file-exists-p repo)
      (make-directory repo t)
      (when (<= emacs-major-version 28) (require 'subr-x))
      (condition-case-unless-debug err
          (if-let* ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                    ((zerop
                      (apply #'call-process
                             `("git" nil ,buffer t "clone"
                               ,@(when-let* ((depth (plist-get order :depth)))
                                   (list
  				  (format "--depth=%d" depth)
  				  "--no-single-branch"))
                               ,(plist-get order :repo) ,repo))))
                    ((zerop (call-process "git" nil buffer t "checkout"
                                          (or (plist-get order :ref) "--"))))
                    (emacs (concat invocation-directory invocation-name))
                    ((zerop (call-process
                             emacs nil buffer nil "-Q" "-L" "." "--batch"
                             "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                    ((require 'elpaca))
                    ((elpaca-generate-autoloads "elpaca" repo)))
              (progn (message "%s" (buffer-string)) (kill-buffer buffer))
            (error "%s" (with-current-buffer buffer (buffer-string))))
        ((error) (warn "%s" err) (delete-directory repo 'recursive))))
    (unless (require 'elpaca-autoloads nil t)
      (require 'elpaca)
      (elpaca-generate-autoloads "elpaca" repo)
      (load "./elpaca-autoloads")))
  (add-hook 'after-init-hook #'elpaca-process-queues)
  (elpaca `(,@elpaca-order))
  (elpaca elpaca-use-package
    (elpaca-use-package-mode))
#+end_src


* Bits and bobs

This is a bunch of other niceties that I would like to have, since that would make configuration and usage a good bit easier.

- Garbage collector reduction for faster startup
- Add all files in the =nano/= directory into the loading path

#+begin_src emacs-lisp
  (setq gc-cons-threshold 63000000
        gc-cons-percentage 0.6)
  (add-to-list 'load-path "~/.config/emacs/nano")
#+end_src

** "Sane defaults"

This section deals with simple default values that I would like to have set by default for /my/ Emacs experience. These are by no means general statements on what should be the defaults.

#+begin_src emacs-lisp
  (setq inhibit-startup-screen t)
  (setq inhibit-startup-message t)
  (setq inhibit-startup-echo-area-message t)
  (setq initial-scratch-message nil)
  (setq initial-buffer-choice nil)

  (setq frame-title-format nil)
  (setq use-file-dialog nil)
  (setq use-dialog-box nil)
  (setq pop-up-windows nil)
  (setq indicate-empty-lines nil)
  (setq cursor-in-non-selected-windows nil)

  (setq initial-major-mode 'text-mode)
  (setq default-major-mode 'text-mode)
  (setq font-lock-maximum-decoration t)
  (setq auto-fill-mode nil)
  (setq fill-column 80)

  (setq-default cursor-type '(hbar .  2))
  (setq-default cursor-in-non-selected-windows nil)
  (setq blink-cursor-mode nil)

  (setq default-frame-alist
        (append (list
                 '(vertical-scroll-bars . nil)
                 '(internal-border-width . 20)
                 '(left-fringe . 16)
                 '(right-fringe . 0)
                 '(undecorated-round . t) ;; emacs-plu@29 only
                 '(scroll-bar-mode . -1)
                 '(tool-bar-lines . 0)
  	       '(tool-bar-position . left)
                 '(menu-bar-lines . 0))))

  (setq tool-bar-style 'image)

  (setq window-divider-default-right-width 20)
  (setq window-divider-default-places 'right-only)
  (window-divider-mode 1)

  (setq make-backup-files nil)

  (set-display-table-slot standard-display-table
                          'truncation
  			(make-glyph-code ?… 'font-lock-comment-face))
  (set-display-table-slot standard-display-table
                          'wrap
  			(make-glyph-code ?- 'font-lock-comment-face))
#+end_src

** Nice-to-haves

The first of likely many is smooth scrolling which I think would make me a lot happier coding in Emacs.

#+begin_src emacs-lisp
  (use-package ultra-scroll
    :ensure t
    :init
    (setq scroll-conservatively 3
  	scroll-margin 0)
    :config
    (ultra-scroll-mode 1))
#+end_src


* Themes and colours

I'm moving from Rougier's =nano-theme= and Prot's =modus-operandi= to a simple application of the Catppuccin themes, assuming there should be some unified way to apply the themes cleanly that works with my personal customizations as well as Rougier's other packages.

** Face overrides

#+begin_src emacs-lisp
  (defun drs/catppuccin-override ()
    "Override Catppuccin theme for specific faces."
    (interactive)
    (set-face-attribute 'org-document-title nil
  		      :foreground (catppuccin-color 'text)
  		      :weight 'bold
  		      :height 1.6)
    (set-face-attribute 'org-level-1 nil
  		      :foreground (catppuccin-color 'text)
  		      :weight 'bold
  		      :height 1.4)
    (set-face-attribute 'org-level-2 nil
  		      :foreground (catppuccin-color 'text)
  		      :weight 'bold
  		      :height 1.2)
    (set-face-attribute 'org-level-3 nil
  		      :foreground (catppuccin-color 'text)
  		      :weight 'bold
  		      :height 1.1)
    (set-face-attribute 'org-level-4 nil
  		      :foreground (catppuccin-color 'text)
  		      :weight 'bold)
    (set-face-attribute 'org-block-begin-line nil
  		      :box `(:line-width 8
  		      :color ,(catppuccin-color 'mantle)))
    (set-face-attribute 'vertical-border nil
  		      :foreground (catppuccin-color 'base))
    (set-face-attribute 'window-divider nil
  		      :foreground (catppuccin-color 'base))
    (set-face-attribute 'window-divider-first-pixel nil
  		      :foreground (catppuccin-color 'base))
    (set-face-attribute 'window-divider-last-pixel nil
  		      :foreground (catppuccin-color 'base))
    (catppuccin-reload))

  (add-hook 'elpaca-after-init-hook #'drs/catppuccin-override)
#+end_src

** Applying the theme

#+begin_src emacs-lisp
    (use-package catppuccin-theme
      :ensure t
      :config
      (setq catppuccin-flavor 'latte)
      (load-theme 'catppuccin t))
#+end_src


* Typography

This is all the stuff I need to improve typography when using Emacs. This includes coding ligatures, icons, and colour code rendering.

** Font setup

I'm using Prot's =fontaine= package to setup my default fonts, independent of Rougier's packages.

#+begin_src emacs-lisp
  (use-package fontaine
    :ensure t
    :config
    (setq fontaine-presets
  	'((default
  	   :default-family "Iosevka"
  	   :fixed-pitch-family "Iosevka"
  	   :variable-pitch-family "Inter"
  	   :mode-line-active-family "Inter"
  	   :mode-line-inactive-family "Inter"
  	   :header-line-family "Inter"

  	   :default-weight regular
  	   :bold-weight semi-bold
  	   :italic-slant italic

  	   :default-height 120
  	   :line-spacing 0.15)))
    (fontaine-set-preset 'default))
#+end_src

Nerd fonts tend to have some hiccups (lots of them), this block here should solve things ideally.

#+begin_src emacs-lisp
  (defun drs/nerd-fonts ()
    "Set up Nerd Fonts for specific codepoints."
    (interactive)
    (set-fontset-font t '(#x23fb . #x23fe) "Symbols Nerd Font")
    (set-fontset-font t '(#x2500 . #x259f) "Symbols Nerd Font")
    (set-fontset-font t '(#x276c . #x2771) "Symbols Nerd Font")
    (set-fontset-font t '(#xe000 . #xe00a) "Symbols Nerd Font")
    (set-fontset-font t '(#xe0a0 . #xe0a3) "Symbols Nerd Font")
    (set-fontset-font t '(#xe0b0 . #xe0d7) "Symbols Nerd Font")
    (set-fontset-font t '(#xe200 . #xe2a9) "Symbols Nerd Font")
    (set-fontset-font t '(#xe300 . #xe3e3) "Symbols Nerd Font")
    (set-fontset-font t '(#xe5fa . #xe6b7) "Symbols Nerd Font")
    (set-fontset-font t '(#xe700 . #xe8ef) "Symbols Nerd Font")
    (set-fontset-font t '(#xea60 . #xec1e) "Symbols Nerd Font")
    (set-fontset-font t '(#xed00 . #xf2ff) "Symbols Nerd Font")
    (set-fontset-font t '(#xee00 . #xee0b) "Symbols Nerd Font")
    (set-fontset-font t '(#xf300 . #xf381) "Symbols Nerd Font")
    (set-fontset-font t '(#xf400 . #xf533) "Symbols Nerd Font")
    (set-fontset-font t '(#xf0001 . #xf1af0) "Symbols Nerd Font"))

  (add-hook 'server-after-make-frame-hook #'drs/nerd-fonts)
#+end_src

** Nice-to-haves

#+begin_src emacs-lisp
  (use-package ligature
    :ensure t
    :config
    (ligature-set-ligatures
     'prog-mode '("<---" "<--"  "<<-" "<-" "->" "-->" "--->" "<->" "<-->" "<--->"
  		"<---->" "<!--" "<==" "<===" "<=" "=>" "=>>" "==>" "===>" ">=" "<=>"
  		"<==>" "<===>" "<====>" "<!---" "<~~" "<~" "~>" "~~>" "::" ":::"
  		"==" "!=" "===" "!==" ":=" ":-" ":+" "<*" "<*>" "*>" "<|" "<|>" "|>"
  		"+:" "-:" "=:" "<******>" "++" "+++"))
    (global-ligature-mode t))


  (use-package nerd-icons
    :ensure t
    :if (display-graphic-p)
    :config
    (setq nerd-icons-font-family "Symbols Nerd Font"))

  (use-package nerd-icons-dired
    :ensure t
    :after nerd-icons
    :hook (dired-mode . nerd-icons-dired-mode))

  (use-package nerd-icons-ibuffer
    :ensure t
    :after nerd-icons
    :hook (ibuffer-mode . nerd-icons-ibuffer-mode)
    :config
    (setq nerd-icons-ibuffer-formats
  	'(("  "
  	   mark " "
  	   (icon 2 2) " "
  	   (name 24 24 :left :elide) "  "))))

  (use-package nerd-icons-corfu
    :ensure t
    :after nerd-icons
    :after corfu
    :config (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))

  (use-package colorful-mode
    :ensure t
    :config
    (global-colorful-mode))

  (elpaca-wait)
#+end_src


* Vim Emulation

I use Evil-mode along with God-mode as an Evil state. I've tried Meow and didn't like it as much. I've tried God-mode as is and loved it, except that it lacked the pure Vim bindings. One issue that I'm still having is that =C-u= to scroll still doesn't work and I don't know why.

Note that there is a ~elpaca-wait~ call at the end because some customizations I use require Evil to be loaded.

#+begin_src emacs-lisp
  (use-package evil :ensure t
    :init
    (setq evil-want-keybinding nil
          evil-undo-system 'undo-redo
          evil-default-state 'normal
          evil-want-C-i-jump t
          evil-want-C-w-delete t
          evil-want-Y-yank-to-eol t
          evil-want-C-u-scroll t
          evil-want-C-d-scroll t)
    :config (evil-mode 1))

  (use-package evil-collection :ensure t :after evil
    :init (evil-collection-init))

  (use-package evil-god-state :ensure t :after evil
    :config
    (evil-define-key 'normal 'global "\\" 'evil-execute-in-god-state)
    (evil-define-key 'god 'global "escape" 'evil-god-state-bail))

  (use-package evil-surround :ensure t :after evil
    :config (global-evil-surround-mode 1))

  (use-package evil-commentary :ensure t :after evil
    :config (evil-commentary-mode))

  (use-package evil-numbers :ensure t :after evil
    :config
    (evil-define-key '(normal visual) 'global
      (kbd "C-a") 'evil-numbers/inc-at-pt
      (kbd "C-x") 'evil-numbers/dec-at-pt
      (kbd "g C-a") 'evil-numbers/inc-at-pt-incremental
      (kbd "g C-x") 'evil-numbers/dec-at-pt-incremental))

  (elpaca-wait)
#+end_src


* GitHub, Copilot and other AI stuff

This sets up three major plugins: Magit (all hail), Copilot, and GPTel. Elpaca throws some weird errors if I don't include the transient =use-package= call.

#+begin_src emacs-lisp
  (use-package transient
    :ensure t)
  (use-package magit
    :ensure t)
#+end_src

Here, I set up the AI-based stuff like copilot (for completions) and GPTel (for other LLM and agent capabilities). I still need to get a handle on what GPTel can do for my particular use case.

#+begin_src emacs-lisp
  (use-package copilot
    :vc (:url "https://github.com/copilot-emacs/copilot.el"
  	    :rev :newest
  	    :branch "main")
    :ensure t
    :hook (prog-mode . (lambda ()
  		       (unless (file-remote-p default-directory)
  			 copilot-mode)))
    :config
    (define-key copilot-completion-map (kbd "<tab>") 'copilot-accept-completion))

  (setq gemini-api-key (with-temp-buffer
  		       (insert-file-contents ".config/emacs/.gemini")
  		       (buffer-string)))

  (use-package gptel
    :ensure t
    :config
    (setq gptel-backend
  	(gptel-make-gemini "Gemini"
  			   :key gemini-api-key
  			   :stream t)
  	gptel-default-mode 'org-mode))
#+end_src

Xenodium has come out with the =agent-shell= package, which I'd like to try out with Gemini CLI. For now, it doesn't seem very stable, so I'll be keeping an eye out on the repo for updates.

#+begin_src emacs-lisp :tangle not-init.el
  (use-package shell-maker
    :ensure t)
  (use-package acp
    :ensure (:host github :repo "xenodium/acp.el"))

  (use-package agent-shell
    :ensure (:host github :repo "xenodium/agent-shell")
    :config
    (setq agent-shell-google-key gemini-api-key))
#+end_src


* Dired

This has some nice features that I would like when using the builtin Dired. The keybinds are to make it more like other Vim-like file managers, particularly Ranger (which is what I used earlier).

#+begin_src emacs-lisp
  (require 'dired)
  (require 'dired-x)
  (setq dired-listing-switches
        "-l --almost-all --human-readable --group-directories-first"
        dired-omit-files
        (concat dired-omit-files "\\|^\\..+$\\|^__pycache__$"))
  (put 'dired-find-alternate-file 'disabled nil)
  (add-hook 'dired-mode-hook 'dired-hide-details-mode)
  (add-hook 'dired-mode-hook 'dired-omit-mode)

  (define-key global-map (kbd "C-x C-d") (lambda () (interactive) (dired ".")))
  (evil-define-key 'normal dired-mode-map
    "g." 'dired-omit-mode
    "h" (lambda () (interactive) (find-file ".."))
    "l" 'dired-find-file
    "L" (lambda () (interactive)
  	(start-process "xdg" nil "xdg-open" (dired-get-file-for-visit)))
    "n" 'evil-search-next
    "N" 'evil-search-previous
    "o" 'dired-sort-toggle-or-edit
    "v" 'dired-toggle-marks
    "m" 'dired-mark
    "u" 'dired-unmark
    "c" 'dired-create-directory
    "t" 'dired-create-empty-file)
  #+end_src

Previews are nice to have, and Prot has a package for this.

#+begin_src emacs-lisp
  (use-package dired-preview
    :ensure t
    :config
    (setq dired-preview-delay 0.1
          dired-preview-max-size (expt 2 23)
          dired-preview-ignored-extensions-regexp
  	(concat "\\."
  		"\\(gz\\|"
  		"zst\\|"
  		"tar\\|"
  		"xz\\|"
  		"rar\\|"
  		"zip\\|"
  		"iso\\|"
  		"epub\\|"
  		"mp4\\|"
  		"flac\\|"
  		"\\)"))
    (dired-preview-global-mode 1))
#+end_src

Dired stuff is still a work in progress.

#+begin_src emacs-lisp :tangle not-init.el
  (use-package dirvish
    :ensure t
    :config
    (dirvish-peek-mode)
    (setq dirvish-attributes '(nerd-icons file-size)))
     #+end_src


* IBuffer

As much as I need some good buffer management tools, I don't like how IBuffer behaves particularly with evil. This is an attempt to make it that much better.

#+begin_src emacs-lisp
  (eval-after-load 'ibuffer
    '(progn
       (evil-set-initial-state 'ibuffer-mode 'normal)
       (evil-define-key 'normal ibuffer-mode-map
         (kbd "v") 'ibuffer-toggle-marks
         (kbd "l") 'ibuffer-visit-buffer)))

  (setq ibuffer-saved-filter-groups
        '(("custom"
  	 ("Emacs config" (filename . ".config/emacs"))
  	 ("QTile config" (filename . ".config/qtile"))
  	 ("Org files" (mode . org-mode))
  	 ("Code" (derived-mode . prog-mode))
  	 ("Shell scripts" (mode . sh-mode))
  	 ("Text files" (and (mode . text-mode)
  			    (not (starred-name))))
  	 ("Dired" (mode . dired-mode))
  	 ("Magit" (name . "\*magit"))
  	 ("Auxiliary buffers" (starred-name)))))
  (setq ibuffer-show-empty-filter-groups nil
        ibuffer-use-header-line nil
        ibuffer-display-summary nil
        ibuffer-eliding-string "…"
        ibuffer-marked-char ?\
        ibuffer-modified-char ?\
        ibuffer-read-only-char ?\
        ibuffer-deletion-char ?\)
#+end_src

The next snippet is all about making the IBuffer buffer that much prettier. This is also pretty much mooched off of Nicolas Rougier's NANO-sidebar package.

#+begin_src emacs-lisp
  (defun ibuffer-advice (_format)
    (with-current-buffer "*Ibuffer*"
      (save-excursion
      (let ((inhibit-read-only t))

        ;; Remove header and insert ours
        (goto-char (point-min))
        (search-forward " \n" nil t)
        (search-forward " \n" nil t)
        (delete-region 1 (point))
        (goto-char (point-min))
        (insert (concat
                 (propertize "\n" 'face '(:height 0.8))
                 (propertize "Buffer List"
                             'face `(org-document-title variable-pitch))
                 (propertize " "  'display `(raise -0.35))
                 "\n"))
        (insert "")

        ;; Transform titles
        (goto-char (point-min))
        (while (re-search-forward "\\[ \\(.*\\) \\]" nil t)
          (let* ((title (match-string 0))
                 (property (get-text-property 0 'ibuffer-filter-group-name title)))
            (replace-match "\n")
            (insert (concat
                     (propertize
                      (substring title 2 -2)
                      'ibuffer-filter-group-name property
  		      'face '(org-level-2 variable-pitch))
                     "\n"))))))))

  (defun ibuffer-setup ()
    (ibuffer-switch-to-saved-filter-groups "custom")
    (ibuffer-auto-mode 1))

  (advice-add 'ibuffer-update-title-and-summary :after #'ibuffer-advice)
  (add-hook 'ibuffer-mode-hook #'ibuffer-setup)
  (define-key global-map (kbd "C-x C-b") 'ibuffer)
#+end_src


* Calc

A dedicated LaTeX mode wasn't enough, now we actually have to do math. The horror!
Jokes aside, I've seen the power of Emacs' built in calculator and I'm sold. I'm also looking forward to the release of Karthink's work on using latex in calc first class.

*NB:* I was going to add casual to this, but I'm considering abandoning it for the built-in [[Which-Key]]

#+begin_src emacs-lisp
#+end_src


* Which-Key

It occurs to me that I am not an Emacs dictionary. Who'd have thunk?

#+begin_src emacs-lisp
  (which-key-mode 1)
  (which-key-setup-side-window-bottom)
  (which-key-enable-god-mode-support)
#+end_src


* Regex builder

I'm starting to find too many insanely cool builtin features in Emacs. The Interactive Regex Builder is another in that huge list.

#+begin_src emacs-lisp
  (require 're-builder)
  (setq reb-re-syntax 'string)
#+end_src


* PDF Tools and ePub reading

This section was originally about LaTeX and its rendering. Now, it's purely for packages that allow reading PDFs and ePubs in Emacs.
*NB:* =nov= for ePubs is kinda jank. I'll have to come up with something better.

#+begin_src emacs-lisp
  (use-package pdf-tools
    :ensure t
    :init
    (pdf-tools-install)
    :hook (pdf-view-mode . (lambda () (pdf-view-themed-minor-mode 1))))

  (use-package nov
    :ensure t)
#+end_src


* Completions and Spellchecking

** Completions at point

I'm (not really) using Corfu at the moment. Haven't tried out other completion frameworks

#+begin_src emacs-lisp
  (use-package corfu
    :ensure t
    :config
    (setq corfu-auto t)
    (global-corfu-mode))
#+end_src

** Spell checking

For spellchecking, I did try out jinx, but never ended up actually using it. Apparently Grammarly's Language Server borked itself, so now I'm switching to the OSS variant called LanguageTool (a maintained fork called LTeX+). Let's see how that goes. For now it's bugged out of its tiny little mind.

#+begin_src emacs-lisp :tangle not-init.el
  (use-package eglot-ltex-plus
    :ensure (:host github :repo "emacs-langtool/eglot-ltex-plus")
    :hook
    ((text-mode markdown-mode org-mode) . (lambda ()
  					  (require 'eglot-ltex-plus)
  					  (eglot-ensure)))
    :init
    (setq eglot-ltex-server-path "~/.config/emacs/ltex/ltex-ls-plus-18.5.1"
  	eglot-ltex-communication-channel 'stdio))
#+end_src

** Syntax checking and diagnostics

For syntax checking, I'm starting to use flymake-mode, which should integrate decently with the version of ~nano-modeline~ that I have.
I'm using custom fringe bitmaps to indicate the locations of errors, warnings and notes.

#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook #'flymake-mode)
  (evil-define-key 'normal flymake-mode-map "]d" 'flymake-goto-next-error)
  (evil-define-key 'normal flymake-mode-map "[d" 'flymake-goto-prev-error)
  (setq flymake-start-on-flymake-mode t
        flymake-indicator-type 'fringes)
#+end_src


* Terminal shenanigans

I'm pretty much set on using =emacs-eat= as a terminal with Eshell. I just need to figure out how to make it look nice, and how to personalize it to my usage. One superpower I read about on Reddit was the usage of snippets in the terminal with YASnippet.

#+begin_src emacs-lisp
  (use-package eat
    :ensure t)
#+end_src

Some eshell niceties are to be expected :P

#+begin_src emacs-lisp
  (setq eshell-prompt-function
  	  (lambda ()
  	    (concat
  	     (propertize "\n" 'face `(:foreground ,(catppuccin-color 'text)
  				      :extend t
  				      :underline ,(catppuccin-color 'subtext0)))
  	     (propertize " " 'face `(:foreground ,(catppuccin-color 'text)
  				     :height 1.6
  				     :weight 'bold))
  	     (propertize "" 'face `(:foreground ,(catppuccin-color 'mauve)
  				     :weight 'bold))
  	     (propertize " " 'face `(:foreground ,(catppuccin-color 'text)
  				     :extend t)))))

  (define-key global-map (kbd "C-x C-s") 'eshell)
#+end_src


* Org Mode and $\LaTeX$

All hail the OrgMode system! Lots of very helpful modules have been used here, and several more can be added once I start getting more comfortable with them.

** Actual Org and LaTeX

First, since we're using ~org-cdlatex-mode~, we need to also install auctex, which might cause some issues.

#+begin_src emacs-lisp
  (use-package auctex
    :ensure (:repo "https://git.savannah.gnu.org/git/auctex.git"
             :branch "main"
  	   :pre-build (("make" "elpa"))
  	   :build (:not elpaca--compile-info)
  	   :files ("*.el" "doc/*.info*" "etc" "images" "latex" "style")
             :version (lambda (_) (require 'auctex) AUCTeX-version)))

  (use-package cdlatex
    :ensure t)
#+end_src

Now we can get back to org.

#+begin_src emacs-lisp
    (cl-pushnew 'org elpaca-ignored-dependencies)

    (use-package org
      :ensure nil
      :hook (org-mode . visual-line-mode)
      :hook (org-mode . mixed-pitch-mode)
      :hook (org-mode . org-display-inline-images)
      :hook (org-mode . turn-on-org-cdlatex)
      :config
      (setq org-ellipsis "..."
    	org-fontify-quote-and-verse-blocks t
            org-hide-emphasis-markers t
            org-hide-leading-stars nil
    	org-cycle-separator-lines 2
            org-pretty-entities t
            org-use-sub-superscripts t
            org-format-latex-options (plist-put org-format-latex-options :scale 1.25)
            org-latex-src-block-backend 'listings
    	org-latex-packages-alist '(("" "amsmath" t)
    				   ("" "amssymb" t)
    				   ("" "mathtools" t)
    				   ("" "braket" t)
    				   ("" "physics" t)
    				   ("" "xcolor" t)
    				   ("" "tikz" t)
    				   ("" "tikz-cd" t))
    	org-todo-keywords '((sequence "TODO" "DOING" "|" "DONE")
    			    (sequence "HOLD" "|" "NOPE"))
    	org-priority-highest 0
            org-priority-lowest 9
    	org-priority-default 5
    	org-agenda-files '("~/Notes/agenda.org")
    	org-hidden-keywords '(title author date)
    	org-src-window-setup 'current-window
            org-capture-templates
            '(("t" "Todo" entry
       	   (file+headline "~/Notes/Productivity/refile.org" "Tasks to refile")
               "* TODO %?\n  %i\n  %a")))
      (org-babel-do-load-languages
       'org-babel-load-languages
       '((emacs-lisp . t)
         (latex . t)
         (python . t)))
      (setf (cdr (assoc 'file org-link-frame-setup)) 'find-file))
#+end_src

** Org-Roam

I'll start using Zettelkasten for my notes, because otherwise I'll end up creating multiple unnecessarily redundant files with either too little or too much information.

#+begin_src emacs-lisp
  (use-package org-roam
    :ensure t
    :config
    (setq org-roam-directory "~/Notes")
    (org-roam-db-autosync-mode)
    :bind (("C-c n f" . 'org-roam-node-find)
  	 ("C-c n i" . 'org-roam-node-insert)
  	 ("C-c n g" . 'org-roam-graph)
	   ("C-c n c" . 'org-roam-capture)))
#+end_src

** Jupyter and other Babel shenanigans

Babel is a module of Org mode that deals with other programming languages and how they integrate with Org. These integrations include "tangling" (bundling all codeblocks in an org file into an actual code file), and running in the file itself.

I use this module greatly for treating Jupyter notebooks and Org files like each other.

This also includes an Export module to export an org file as a Jupyter notebook

#+begin_src emacs-lisp
  (use-package ob-ipython
    :ensure t
    :after org
    :config
    (add-to-list 'org-babel-load-languages '(ipython . t))
    (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages))

  (use-package jupyter
    :ensure t
    :after org
    :config
    (add-to-list 'org-babel-load-languages '(jupyter . t))
    (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages))

(use-package ox-ipynb
  :ensure (ox-ipynb :host github :repo "jkitchin/ox-ipynb")
  :after org)
#+end_src

*** Auto tangling

#+begin_src emacs-lisp
  (use-package org-auto-tangle
    :ensure t
    :after org
    :hook (org-mode . org-auto-tangle-mode))
#+end_src

** Citation management

Zotero is a gem, but it's a little messy to integrate into my Org-LaTeX documents, but I've heard of Citar which seems to make it /schmooth/.

#+begin_src emacs-lisp
  (use-package citar
    :ensure t
    :custom
    (org-cite-global-bibliography '("~/Research/Bibliography/NLP-Stuff.bib"
  				  "~/Research/Bibliography/Math-Stuff.bib"
  				  "~/Research/Bibliography/Other-Fun-Stuff.bib"))
    (org-cite-insert-processor 'citar)
    (org-cite-follow-processor 'citar)
    (org-cite-activate-processor 'citar)
    (citar-bibliography org-cite-global-bibliography)
    :bind
    (:map org-mode-map :package org ("C-c i" . #'org-cite-insert))
    :config
    (defvar citar-indicator-notes-icons
      (citar-indicator-create
       :symbol (nerd-icons-mdicon
  	      "nf-md-notebook"
  	      :face 'nerd-icons-blue
  	      :v-adjust -0.3)
       :function #'citar-has-notes
       :padding "  "
       :tag "has:notes"))

    (defvar citar-indicator-links-icons
      (citar-indicator-create
       :symbol (nerd-icons-octicon
                "nf-oct-link"
                :face 'nerd-icons-orange
                :v-adjust -0.1)
       :function #'citar-has-links
       :padding "  "
       :tag "has:links"))

    (defvar citar-indicator-files-icons
      (citar-indicator-create
       :symbol (nerd-icons-faicon
                "nf-fa-file"
                :face 'nerd-icons-green
                :v-adjust -0.1)
       :function #'citar-has-files
       :padding "  "
       :tag "has:files"))
    (setq citar-indicators
  	(list citar-indicator-files-icons
  	      citar-indicator-notes-icons
  	      citar-indicator-links-icons)))

#+end_src

** UI Stuff

These are some nice-to-haves that make Org files look good in Emacs.

#+begin_src emacs-lisp
  (use-package org-autolist
    :ensure t
    :after org
    :hook (org-mode . org-autolist-mode))

  (use-package mixed-pitch
    :ensure t
    :after org
    :hook (org-mode . mixed-pitch-mode))
#+end_src

*** Markdown

Markdown is surprisingly similar to Org notation, but the rendering isn't nearly as good. I'll be fixing that here (as much as I can). Some changes are in the [[Face Overrides]] subsection of the themes section.

There's also a neat little toggle for the plaintext vs rendered text mode.

#+begin_src emacs-lisp
  (add-hook 'markdown-mode-hook #'mixed-pitch-mode)
  (add-hook 'markdown-view-mode-hook #'mixed-pitch-mode)

  (defun drs/toggle-view ()
    "Toggle markdown view mode."
    (interactive)
    (if (eq major-mode 'markdown-mode)
        (markdown-view-mode)
      (markdown-mode)))
  (add-hook 'markdown-mode-hook (lambda ()
  				(define-key markdown-mode-map (kbd "C-c m")
  					    'drs/toggle-view)))
#+end_src


* Treesitter and LSP

This feels more comfortable and simultaneously not. I need to get more comfortable with both of these as they are implemented in Emacs.

#+begin_src emacs-lisp
  (use-package treesit-auto
    :ensure t
    :custom
    (treesit-auto-install 'prompt)
    :config
    (treesit-auto-add-to-auto-mode-alist 'all)
    (global-treesit-auto-mode))

  (setq treesit-font-lock-level 4)

  (use-package exec-path-from-shell
    :ensure t
    :config
    (exec-path-from-shell-initialize))

  (evil-define-key 'normal eglot-mode-map
    (kbd "g Q") 'eglot-format-buffer
    (kbd "g R") 'eglot-rename
    (kbd "g C") 'eglot-code-actions)
#+end_src

Another programming nice-to-have :P

#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook #'electric-pair-mode)
#+end_src


* Snippets

I'm starting to get the idea that snippets are going to be very useful. (Who'd have thought?)
I'm using good old =yasnippet= for this.

#+begin_src emacs-lisp
  (use-package yasnippet
    :ensure t
    :config
    (yas-global-mode 1)
    (setq yas-snippet-dirs '(".config/emacs/snippets")))
    #+end_src


* Minibuffer (basically Vertico)

This customizes the way the Minibuffer works in Emacs.

Dream feature (which is honestly impossible): I'd like Evil to mimic the use of native features in completion, in the sense that =:= ends up behaving like =M-x= in the way it pops up vertico with completions. Similarly with =/= and =consult-line= and so on.

#+begin_src emacs-lisp
  (use-package vertico
    :ensure t
    :config
    (vertico-buffer-mode)
    (vertico-mode 1)
    (setq vertico-preselect 'first
  	vertico-count 10
  	vertico-resize nil))

  (use-package marginalia
    :ensure t
    :config
    (marginalia-mode))

  (use-package orderless
    :ensure t
    :custom
    (completion-styles '(orderless basic))
    (completion-category-overrides '((file (styles basic partial-completion)))))

  (use-package consult
    :ensure t
    :config
    (setq completion-in-region-function 'consult-completion-in-region))
#+end_src


* RSS Feeds

I'll be using Elfeed as my RSS reader for news and tech updates.

#+begin_src emacs-lisp
  (use-package stripes :ensure t)
  (use-package elfeed :ensure t)
  (use-package elfeed-org :ensure t :after elfeed :config (elfeed-org))
#+end_src


* Other esoteric stuff

Stuff that is just here to get one task or a few tasks done, not worth going too deep into.

** Dyalog APL

I did try learning Dyalog APL for the APL Forge contest, and found it quite cool. Nice to have a minor mode (and sometime later, and input-mode) for it. Not in use currently

#+begin_src emacs-lisp :tangle not-init.el
  (use-package dyalog-mode
    :ensure t
    :config
    (defun org-babel-execute:dyalog (body params)
      (org-babel-execute:jupyter-apl body params))

    (defun org-babel-dyalog-initiate-session (&optional arg1 arg2)
      (org-babel-jupyter-apl-initiate-session &optional arg1 arg2))

    (setq org-babel-default-header-args:jupyter-apl '((:kernel . "dyalog_apl")
                                                      (:session . "*new*")
                                                      (:exports . "both")
                                                      (:eval . "never-export"))

          org-babel-default-header-args:dyalog '((:kernel . "dyalog_apl")
                                                 (:session . "*new*")
                                                 (:exports . "both")
                                                 (:eval . "never-export"))))
#+end_src


* NΛNO Emacs modules

This is the bit that was (more or less) entirely copy-pasted from Nicolas Rougier's repositories. These are what make Emacs look so incredibly clean. After yoinking them from the repos, I've made major changes to them in order to make them more compatible with my editing style and colour scheme.

For now, I'll be keeping all the Elisp in separate files in the =nano/= directory and ~require~-ing them here. Ideally I would like to include all Elisp in this file, but that might make this unreadable.

#+begin_src emacs-lisp
  (add-hook 'elpaca-after-init-hook
            (lambda ()
              (progn
                (require 'nano-modeline)
                (nano-modeline nil nil t)
                (require 'nano-vertico)
                (nano-vertico-mode)

                (require 'nano-splash)
                (require 'nano-calendar)
                (require 'nano-agenda)

                (require 'nano-read)
  	      (require 'nano-sidebar)

                (require 'nano-org)

                ;; (require 'nano-elfeed)
                (require 'nano-kill)
                (require 'nano-block))))
#+end_src
  
                
