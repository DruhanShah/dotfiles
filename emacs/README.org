#+title: Druhan's Emacs Configuration
#+author: Druhan Shah

#+startup: overview
#+property: header-args :tangle init.el
#+auto_tangle: t

This configuration is heavily based off of [[https://github.com/rougier][Nicolas Rougier]]'s emacs packages and ideas. All the packages taken more or less verbatim from Mr. Rougier's repositories are in the =nano/= directory and any other configuration files are in the =not-nano/= directory.

This is a literate configuration, which means all the code blocks in this Org file will be exported using Org-Babel's tangle feature into their corresponding config files on save. As a result, all the configuration necessary will be in this file as far as possible. Sometime in the future, a Table of Contents will be implemented to make navigating this document easier.

* Preambles 

The Early-Init file is executed before =init.el=, and hence is where we disable =package.el= in favour of Elpaca.

#+begin_src emacs-lisp :tangle early-init.el
  ;; Early-init file, executed before init.el when starting Emacs

  (setq package-enable-at-startup nil)
#+end_src

Now, we throw in a preamble comment in the Init file just in case someone reads it before this README :P

#+begin_src emacs-lisp
  ;; ---------------------------------------------
  ;;              EMACS INIT FILE
  ;; 
  ;; This is where all of my configuration for
  ;; GNU Emacs resides. Please read README.org for
  ;; more detailed information about the config.
  ;; ---------------------------------------------
#+end_src


* Package Manager (Elpaca)

This codeblock is directly from the Elpaca repository's README. I have only added a final expression integrating Elpaca with ~use-package~.

#+begin_src emacs-lisp
  (defvar elpaca-installer-version 0.11)
  (defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
  (defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
  (defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
  (defvar elpaca-order
    '(elpaca :repo "https://github.com/progfolio/elpaca.git"
             :ref nil :depth 1 :inherit ignore
             :files (:defaults "elpaca-test.el" (:exclude "extensions"))
             :build (:not elpaca--activate-package)))
  (let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
         (build (expand-file-name "elpaca/" elpaca-builds-directory))
         (order (cdr elpaca-order))
         (default-directory repo))
    (add-to-list 'load-path (if (file-exists-p build) build repo))
    (unless (file-exists-p repo)
      (make-directory repo t)
      (when (<= emacs-major-version 28) (require 'subr-x))
      (condition-case-unless-debug err
          (if-let* ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                    ((zerop
                      (apply #'call-process
                             `("git" nil ,buffer t "clone"
                               ,@(when-let* ((depth (plist-get order :depth)))
                                   (list
  				  (format "--depth=%d" depth)
  				  "--no-single-branch"))
                               ,(plist-get order :repo) ,repo))))
                    ((zerop (call-process "git" nil buffer t "checkout"
                                          (or (plist-get order :ref) "--"))))
                    (emacs (concat invocation-directory invocation-name))
                    ((zerop (call-process
                             emacs nil buffer nil "-Q" "-L" "." "--batch"
                             "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                    ((require 'elpaca))
                    ((elpaca-generate-autoloads "elpaca" repo)))
              (progn (message "%s" (buffer-string)) (kill-buffer buffer))
            (error "%s" (with-current-buffer buffer (buffer-string))))
        ((error) (warn "%s" err) (delete-directory repo 'recursive))))
    (unless (require 'elpaca-autoloads nil t)
      (require 'elpaca)
      (elpaca-generate-autoloads "elpaca" repo)
      (load "./elpaca-autoloads")))
  (add-hook 'after-init-hook #'elpaca-process-queues)
  (elpaca `(,@elpaca-order))
  (elpaca elpaca-use-package
    (elpaca-use-package-mode))
#+end_src


* Bits and bobs

This is a bunch of other niceties that I would like to have, since that would make configuration and usage a good bit easier.

- Garbage collector reduction for faster startup
- Add all files in the =nano/= directory into the loading path

#+begin_src emacs-lisp
  (setq gc-cons-threshold 63000000
        gc-cons-percentage 0.6)
  (add-to-list 'load-path "~/.config/emacs/nano")
#+end_src

** "Sane defaults"

This section deals with simple default values that I would like to have set by default for /my/ Emacs experience. These are by no means general statements on what should be the defaults.

#+begin_src emacs-lisp
  (setq inhibit-startup-screen t)
  (setq inhibit-startup-message t)
  (setq inhibit-startup-echo-area-message t)
  (setq initial-scratch-message nil)
  (setq initial-buffer-choice nil)

  (setq frame-title-format nil)
  (setq use-file-dialog nil)
  (setq use-dialog-box nil)
  (setq pop-up-windows nil)
  (setq indicate-empty-lines nil)
  (setq cursor-in-non-selected-windows nil)

  (setq initial-major-mode 'text-mode)
  (setq default-major-mode 'text-mode)
  (setq font-lock-maximum-decoration t)
  (setq auto-fill-mode nil)
  (setq fill-column 80)

  (setq-default cursor-type '(hbar .  2))
  (setq-default cursor-in-non-selected-windows nil)
  (setq blink-cursor-mode nil)

  (setq default-frame-alist
        (append (list
                 '(vertical-scroll-bars . nil)
                 '(internal-border-width . 24)
                 '(left-fringe . 16)
                 '(right-fringe . 0)
                 '(undecorated-round . t) ;; emacs-plu@29 only
                 '(scroll-bar-mode . -1)
                 '(tool-bar-lines . 0)
  	 '(tool-bar-position . left)
                 '(menu-bar-lines . 0))))

  (setq tool-bar-style 'image)

  (setq window-divider-default-right-width 24)
  (setq window-divider-default-places 'right-only)
  (window-divider-mode 1)

  (setq make-backup-files nil)

  (set-display-table-slot standard-display-table
                          'truncation
  			(make-glyph-code ?… 'font-lock-comment-face))
  (set-display-table-slot standard-display-table
                          'wrap
  			(make-glyph-code ?- 'font-lock-comment-face))
#+end_src


* Themes and colours

I'm moving from Rougier's =nano-theme= and Prot's =modus-operandi= to a simple application of the Catppuccin themes, assuming there should be some unified way to apply the themes cleanly that works with my personal customizations as well as Rougier's other packages.

** Face overrides

#+begin_src emacs-lisp
  (defun drs/catppuccin-override ()
    "Override Catppuccin theme for specific faces."
    (interactive)
    (set-face-attribute 'org-document-title nil
  		      :foreground (catppuccin-color 'text)
  		      :weight 'bold
  		      :height 1.6)
    (set-face-attribute 'org-level-1 nil
  		      :foreground (catppuccin-color 'text)
  		      :weight 'bold
  		      :height 1.4)
    (set-face-attribute 'org-level-2 nil
  		      :foreground (catppuccin-color 'text)
  		      :weight 'bold
  		      :height 1.2)
    (set-face-attribute 'org-level-3 nil
  		      :foreground (catppuccin-color 'text)
  		      :weight 'bold
  		      :height 1.1)
    (set-face-attribute 'org-level-4 nil
  		      :foreground (catppuccin-color 'text)
  		      :weight 'bold)
    (set-face-attribute 'org-block-begin-line nil
  		      :box `(:line-width 8
  		      :color ,(catppuccin-color 'mantle)))
    (set-face-attribute 'vertical-border nil
  		      :foreground (catppuccin-color 'base))
    (set-face-attribute 'window-divider nil
  		      :foreground (catppuccin-color 'base))
    (set-face-attribute 'window-divider-first-pixel nil
  		      :foreground (catppuccin-color 'base))
    (set-face-attribute 'window-divider-last-pixel nil
  		      :foreground (catppuccin-color 'base))
    (catppuccin-reload))

  (add-hook 'elpaca-after-init-hook #'drs/catppuccin-override)
#+end_src

** Applying the theme

#+begin_src emacs-lisp
    (use-package catppuccin-theme
      :ensure t
      :config
      (setq catppuccin-flavor 'latte)
      (load-theme 'catppuccin t))
#+end_src


* Typography

This is all the stuff I need to improve typography when using Emacs. This includes coding ligatures, icons, and colour code rendering.

** Font setup

I'm using Prot's =fontaine= package to setup my default fonts, independent of Rougier's packages.

#+begin_src emacs-lisp
  (use-package fontaine
    :ensure t
    :config
    (setq fontaine-presets
  	'((default
  	   :default-family "Iosevka"
  	   :fixed-pitch-family "Iosevka"
  	   :variable-pitch-family "Inter"
  	   :mode-line-active-family "Inter"
  	   :mode-line-inactive-family "Inter"
  	   :header-line-family "Inter"

  	   :default-weight regular
  	   :bold-weight semi-bold
  	   :italic-slant italic

  	   :default-height 120
  	   :line-spacing 0.15)))
    (fontaine-set-preset 'default))
#+end_src

Nerd fonts tend to have some hiccups (lots of them), this block here should solve things ideally.

#+begin_src emacs-lisp
  (defun drs/nerd-fonts ()
    "Set up Nerd Fonts for specific codepoints."
    (interactive)
    (set-fontset-font t '(#x23fb . #x23fe) "Symbols Nerd Font")
    (set-fontset-font t '(#x2500 . #x259f) "Symbols Nerd Font")
    (set-fontset-font t '(#x276c . #x2771) "Symbols Nerd Font")
    (set-fontset-font t '(#xe000 . #xe00a) "Symbols Nerd Font")
    (set-fontset-font t '(#xe0a0 . #xe0a3) "Symbols Nerd Font")
    (set-fontset-font t '(#xe0b0 . #xe0d7) "Symbols Nerd Font")
    (set-fontset-font t '(#xe200 . #xe2a9) "Symbols Nerd Font")
    (set-fontset-font t '(#xe300 . #xe3e3) "Symbols Nerd Font")
    (set-fontset-font t '(#xe5fa . #xe6b7) "Symbols Nerd Font")
    (set-fontset-font t '(#xe700 . #xe8ef) "Symbols Nerd Font")
    (set-fontset-font t '(#xea60 . #xec1e) "Symbols Nerd Font")
    (set-fontset-font t '(#xed00 . #xf2ff) "Symbols Nerd Font")
    (set-fontset-font t '(#xee00 . #xee0b) "Symbols Nerd Font")
    (set-fontset-font t '(#xf300 . #xf381) "Symbols Nerd Font")
    (set-fontset-font t '(#xf400 . #xf533) "Symbols Nerd Font")
    (set-fontset-font t '(#xf0001 . #xf1af0) "Symbols Nerd Font"))

  (add-hook 'server-after-make-frame-hook #'drs/nerd-fonts)
#+end_src

** Nice-to-haves

#+begin_src emacs-lisp
  (use-package ligature
    :ensure t
    :config
    (ligature-set-ligatures
     'prog-mode '("<---" "<--"  "<<-" "<-" "->" "-->" "--->" "<->" "<-->" "<--->"
  		"<---->" "<!--" "<==" "<===" "<=" "=>" "=>>" "==>" "===>" ">=" "<=>"
  		"<==>" "<===>" "<====>" "<!---" "<~~" "<~" "~>" "~~>" "::" ":::"
  		"==" "!=" "===" "!==" ":=" ":-" ":+" "<*" "<*>" "*>" "<|" "<|>" "|>"
  		"+:" "-:" "=:" "<******>" "++" "+++"))
    (global-ligature-mode t))


  (use-package nerd-icons
    :ensure t
    :if (display-graphic-p)
    :config
    (setq nerd-icons-font-family "Symbols Nerd Font"))

  (use-package nerd-icons-dired
    :ensure t
    :after nerd-icons
    :hook (dired-mode . nerd-icons-dired-mode))

  (use-package nerd-icons-ibuffer
    :ensure t
    :after nerd-icons
    :hook (ibuffer-mode . nerd-icons-ibuffer-mode)
    :config
    (setq nerd-icons-ibuffer-formats
  	'(("  "
  	   mark " "
  	   (icon 2 2) " "
  	   (name 24 24 :left :elide) "  "))))

  (use-package nerd-icons-corfu
    :ensure t
    :after nerd-icons
    :after corfu
    :config (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))

  (use-package colorful-mode
    :ensure t
    :config
    (global-colorful-mode))

  (setq underline-minimum-offset 100)
  (elpaca-wait)
#+end_src


* Vim Emulation

I use Evil-mode along with God-mode as an Evil state. I've tried Meow and didn't like it as much. I've tried God-mode as is and loved it, except that it lacked the pure Vim bindings. One issue that I'm still having is that =C-u= to scroll still doesn't work and I don't know why.

Note that there is a ~elpaca-wait~ call at the end because some customizations I use require Evil to be loaded.

#+begin_src emacs-lisp
  (use-package evil :ensure t
    :init
    (setq evil-want-keybinding nil
          evil-undo-system 'undo-redo
          evil-default-state 'normal
          evil-want-C-i-jump t
          evil-want-C-w-delete t
          evil-want-Y-yank-to-eol t
          evil-want-C-u-scroll t
          evil-want-C-d-scroll t)
    :config (evil-mode 1))

  (use-package evil-collection :ensure t :after evil
    :init (evil-collection-init))

  (use-package evil-god-state :ensure t :after evil
    :config
    (evil-define-key 'normal 'global "\\" 'evil-execute-in-god-state)
    (evil-define-key 'god 'global "escape" 'evil-god-state-bail))

  (use-package evil-surround :ensure t :after evil
    :config (global-evil-surround-mode 1))

  (use-package evil-commentary :ensure t :after evil
    :config (evil-commentary-mode))

  (use-package evil-numbers :ensure t :after evil
    :config
    (evil-define-key '(normal visual) 'global
      (kbd "C-a") 'evil-numbers/inc-at-pt
      (kbd "C-x") 'evil-numbers/dec-at-pt
      (kbd "g C-a") 'evil-numbers/inc-at-pt-incremental
      (kbd "g C-x") 'evil-numbers/dec-at-pt-incremental))

  (elpaca-wait)
#+end_src


* Copilot and other GitHub stuff

This sets up three major plugins: Magit (all hail), Copilot, and Copilot-chat. Transient is in there to avoid some inexplicable errors with Elpaca.

#+begin_src emacs-lisp
  (use-package transient
    :ensure t)

  (use-package magit
    :ensure t)
#+end_src

This is a bunch of stuff that causes bugs so I need to fix it rq.

#+begin_src emacs-lisp
  (use-package copilot
    :vc (:url "https://github.com/copilot-emacs/copilot.el"
         :rev :newest
         :branch "main")
    :ensure t
    :hook (prog-mode . (lambda ()
  		       (unless (file-remote-p default-directory)
  			 copilot-mode)))
    :config
    (define-key copilot-completion-map (kbd "<tab>") 'copilot-accept-completion))

  (use-package copilot-chat
    :vc (:url "https://github.com/chep/copilot-chat.el"
         :rev :newest
         :branch "main")
    :ensure t
    :after (request org markdown-mode))
#+end_src


* Dired

This has some nice features that I would like when using the builtin Dired. The keybinds are to make it more like other Vim-like file managers, particularly Ranger (which is what I used earlier).

#+begin_src emacs-lisp
  (require 'dired)
  (require 'dired-x)
  (setq dired-listing-switches
        "-l --almost-all --human-readable --group-directories-first"
  	dired-omit-files
        (concat dired-omit-files "\\|^\\..+$\\|^__pycache__$"))
  (put 'dired-find-alternate-file 'disabled nil)
  (add-hook 'dired-mode-hook 'dired-hide-details-mode)
  (add-hook 'dired-mode-hook 'dired-omit-mode)

  (define-key global-map (kbd "C-x C-d") (lambda () (interactive) (dired ".")))
  (evil-define-key 'normal dired-mode-map
    "g." 'dired-omit-mode
    "h" (lambda () (interactive) (find-file ".."))
    "l" 'dired-find-file
    "L" (lambda () (interactive)
	  (start-process "xdg" nil "xdg-open" (dired-get-file-for-visit)))
    "n" 'evil-search-next
    "N" 'evil-search-previous
    "o" 'dired-sort-toggle-or-edit
    "v" 'dired-toggle-marks
    "m" 'dired-mark
    "u" 'dired-unmark
    "c" 'dired-create-directory
    "t" 'dired-create-empty-file)
  #+end_src


* IBuffer

As much as I need some good buffer management tools, I don't like how IBuffer behaves particularly with evil. This is an attempt to make it that much better.

#+begin_src emacs-lisp
  (eval-after-load 'ibuffer
    '(progn
       (evil-set-initial-state 'ibuffer-mode 'normal)
       (evil-define-key 'normal ibuffer-mode-map
         (kbd "v") 'ibuffer-toggle-marks
         (kbd "l") 'ibuffer-visit-buffer)))

  (setq ibuffer-saved-filter-groups
        '(("custom"
  	 ("Emacs config" (filename . ".config/emacs"))
  	 ("QTile config" (filename . ".config/qtile"))
  	 ("Org files" (mode . org-mode))
  	 ("Code" (derived-mode . prog-mode))
  	 ("Shell scripts" (mode . sh-mode))
  	 ("Text files" (and (mode . text-mode)
  			    (not (starred-name))))
  	 ("Dired" (mode . dired-mode))
  	 ("Magit" (name . "\*magit"))
  	 ("Auxiliary buffers" (starred-name)))))
  (setq ibuffer-show-empty-filter-groups nil
        ibuffer-use-header-line nil
        ibuffer-display-summary nil
        ibuffer-eliding-string "…"
        ibuffer-marked-char ?\
        ibuffer-modified-char ?\
        ibuffer-read-only-char ?\
        ibuffer-deletion-char ?\)
#+end_src

The next snippet is all about making the IBuffer buffer that much prettier. This is also pretty much mooched off of Nicolas Rougier's NANO-sidebar package.

#+begin_src emacs-lisp
  (defun ibuffer-advice (_format)
    (with-current-buffer "*Ibuffer*"
      (save-excursion
      (let ((inhibit-read-only t))

        ;; Remove header and insert ours
        (goto-char (point-min))
        (search-forward " \n" nil t)
        (search-forward " \n" nil t)
        (delete-region 1 (point))
        (goto-char (point-min))
        (insert (concat
                 (propertize "\n" 'face '(:height 0.8))
                 (propertize "Buffer List"
                             'face `(org-document-title variable-pitch))
                 (propertize " "  'display `(raise -0.35))
                 "\n"))
        (insert "")

        ;; Transform titles
        (goto-char (point-min))
        (while (re-search-forward "\\[ \\(.*\\) \\]" nil t)
          (let* ((title (match-string 0))
                 (property (get-text-property 0 'ibuffer-filter-group-name title)))
            (replace-match "\n")
            (insert (concat
                     (propertize
                      (substring title 2 -2)
                      'ibuffer-filter-group-name property
  		      'face '(org-level-2 variable-pitch))
                     "\n"))))))))

  (defun ibuffer-setup ()
    (ibuffer-switch-to-saved-filter-groups "custom")
    (ibuffer-auto-mode 1))

  (advice-add 'ibuffer-update-title-and-summary :after #'ibuffer-advice)
  (add-hook 'ibuffer-mode-hook #'ibuffer-setup)
  (define-key global-map (kbd "C-x C-b") 'ibuffer)
#+end_src


* PDF Tools and ePub reading

This section was originally about LaTeX and its rendering. Now, it's purely for packages that allow reading PDFs and ePubs in Emacs.
*NB:* =nov= for ePubs is kinda jank. I'll have to come up with something better.

#+begin_src emacs-lisp
  (use-package pdf-tools
    :ensure t
    :init
    (pdf-tools-install)
    :hook (pdf-view-mode . (lambda () (pdf-view-themed-minor-mode 1))))

  (use-package nov
    :ensure t)
#+end_src


* Completions and Spellchecking

** Completions at point

I'm (not really) using Corfu at the moment. Haven't tried out other completion frameworks

#+begin_src emacs-lisp
  (use-package corfu
    :ensure t
    :config
    (setq corfu-auto t)
    (global-corfu-mode))
#+end_src

** Spell checking

For spellchecking, I did try out jinx, but never ended up actually using it. I'll consider a retry eventually.

#+begin_src emacs-lisp :tangle not-init.el
  ;; Spellchecking not set up yet.
#+end_src

** Syntax checking and diagnostics

For syntax checking, I'm starting to use flymake-mode, which should integrate decently with the version of ~nano-modeline~ that I have.
I'm using custom fringe bitmaps to indicate the locations of errors, warnings and notes.

#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook #'flymake-mode)
  (evil-define-key 'normal flymake-mode-map "]d" 'flymake-goto-next-error)
  (evil-define-key 'normal flymake-mode-map "[d" 'flymake-goto-prev-error)
  (setq flymake-start-on-flymake-mode t
        flymake-indicator-type 'fringes)
#+end_src


* Terminal shenanigans

I'm pretty much set on using =emacs-eat= as a terminal with Eshell. I just need to figure out how to make it look nice, and how to personalize it to my usage. One superpower I read about on Reddit was the usage of snippets in the terminal with YASnippet.

#+begin_src emacs-lisp
  (use-package eat
    :ensure t)
#+end_src

Some eshell niceties are to be expected :P

#+begin_src emacs-lisp
  (setq eshell-prompt-function
  	  (lambda ()
  	    (concat
  	     (propertize "\n" 'face `(:foreground ,(catppuccin-color 'text)
  				      :extend t
  				      :underline ,(catppuccin-color 'subtext0)))
  	     (propertize " " 'face `(:foreground ,(catppuccin-color 'text)
  				     :height 1.6
  				     :weight 'bold))
  	     (propertize "" 'face `(:foreground ,(catppuccin-color 'mauve)
  				     :weight 'bold))
  	     (propertize " " 'face `(:foreground ,(catppuccin-color 'text)
  				     :extend t)))))

  (define-key global-map (kbd "C-x C-s") 'eshell)
#+end_src


* Org Mode and $\LaTeX$

All hail the OrgMode system! Lots of very helpful modules have been used here, and several more can be added once I start getting more comfortable with them.

First, since we're using ~org-cdlatex-mode~, we need to also install auctex, which might cause some issues.

#+begin_src emacs-lisp
  (use-package auctex
    :ensure (:repo "https://git.savannah.gnu.org/git/auctex.git"
             :branch "main"
  	   :pre-build (("make" "elpa"))
  	   :build (:not elpaca--compile-info)
  	   :files ("*.el" "doc/*.info*" "etc" "images" "latex" "style")
             :version (lambda (_) (require 'auctex) AUCTeX-version)))

  (use-package cdlatex
    :ensure t)
#+end_src

Now we can get back to org.

#+begin_src emacs-lisp
    (cl-pushnew 'org elpaca-ignored-dependencies)

    (use-package org
      :ensure nil
      :hook (org-mode . visual-line-mode)
      :hook (org-mode . mixed-pitch-mode)
      :hook (org-mode . org-display-inline-images)
      :hook (org-mode . turn-on-org-cdlatex)
      :config
      (setq org-ellipsis "..."
    	org-fontify-quote-and-verse-blocks t
            org-hide-emphasis-markers t
            org-hide-leading-stars nil
    	org-cycle-separator-lines 2
            org-pretty-entities t
            org-use-sub-superscripts t
            org-format-latex-options (plist-put org-format-latex-options :scale 1.25)
            org-latex-src-block-backend 'listings
    	org-latex-packages-alist '(("" "amsmath" t)
    				   ("" "amssymb" t)
    				   ("" "mathtools" t)
    				   ("" "braket" t)
    				   ("" "physics" t)
    				   ("" "xcolor" t)
    				   ("" "tikz" t)
    				   ("" "tikz-cd" t))
    	org-todo-keywords '((sequence "TODO" "DOING" "|" "DONE")
    			    (sequence "HOLD" "|" "NOPE"))
    	org-priority-highest 0
            org-priority-lowest 9
    	org-priority-default 5
    	org-agenda-files '("~/Notes/agenda.org")
    	org-hidden-keywords '(title author date)
    	org-src-window-setup 'current-window
            org-capture-templates
            '(("t" "Todo" entry
       	   (file+headline "~/Notes/Productivity/refile.org" "Tasks to refile")
               "* TODO %?\n  %i\n  %a")))
      (org-babel-do-load-languages
       'org-babel-load-languages
       '((emacs-lisp . t)
         (latex . t)
         (python . t)))
      (setf (cdr (assoc 'file org-link-frame-setup)) 'find-file))
#+end_src

** Org-Roam

I'll start using Zettelkasten for my notes, because otherwise I'll end up creating multiple unnecessarily redundant files with either too little or too much information.

#+begin_src emacs-lisp
  (use-package org-roam
    :ensure t
    :config
    (setq org-roam-directory "~/Notes")
    (org-roam-db-autosync-mode)
    :bind (("C-c n f" . 'org-roam-node-find)
  	 ("C-c n i" . 'org-roam-node-insert)
  	 ("C-c n g" . 'org-roam-graph)
	   ("C-c n c" . 'org-roam-capture)))
#+end_src

** Jupyter and other Babel shenanigans

Babel is a module of Org mode that deals with other programming languages and how they integrate with Org. These integrations include "tangling" (bundling all codeblocks in an org file into an actual code file), and running in the file itself.

I use this module greatly for treating Jupyter notebooks and Org files like each other.

This also includes an Export module to export an org file as a Jupyter notebook

#+begin_src emacs-lisp
  (use-package ob-ipython
    :ensure t
    :after org
    :config
    (add-to-list 'org-babel-load-languages '(ipython . t))
    (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages))

  (use-package jupyter
    :ensure t
    :after org
    :config
    (add-to-list 'org-babel-load-languages '(jupyter . t))
    (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages))

(use-package ox-ipynb
  :ensure (ox-ipynb :host github :repo "jkitchin/ox-ipynb")
  :after org)
#+end_src

*** Auto tangling

#+begin_src emacs-lisp
  (use-package org-auto-tangle
    :ensure t
    :after org
    :hook (org-mode . org-auto-tangle-mode))
#+end_src

** Google Calendar

I would like to be able to sync my Org agenda and other task and schedule management with Google Calendar (unless I find a way to use the Agenda on mobile :P)

Never mind, I'm discarding this module since it causes security issues, and has several bugs that I'd rather not have in my daily drive system. I'll still be working on making it usable for me.

** UI Stuff

These are some nice-to-haves that make Org files look good in Emacs.

#+begin_src emacs-lisp
  (use-package org-autolist
    :ensure t
    :after org
    :hook (org-mode . org-autolist-mode))

  (use-package mixed-pitch
    :ensure t
    :after org
    :hook (org-mode . mixed-pitch-mode))
#+end_src


* Treesitter and LSP

This feels more comfortable and simultaneously not. I need to get more comfortable with both of these as they are implemented in Emacs.

#+begin_src emacs-lisp
  (use-package treesit-auto
    :ensure t
    :custom
    (treesit-auto-install 'prompt)
    :config
    (treesit-auto-add-to-auto-mode-alist 'all)
    (global-treesit-auto-mode))

  (setq treesit-font-lock-level 4)

  (use-package exec-path-from-shell
    :ensure t
    :config
    (exec-path-from-shell-initialize))

  (evil-define-key 'normal eglot-mode-map
    (kbd "g Q") 'eglot-format-buffer
    (kbd "g R") 'eglot-rename
    (kbd "g C") 'eglot-code-actions)
#+end_src

Another programming nice-to-have :P

#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook #'electric-pair-mode)
#+end_src


* Snippets

I'm starting to get the idea that snippets are going to be very useful. (Who'd have thought?)
I'm using good old =yasnippet= for this.

#+begin_src emacs-lisp
  (use-package yasnippet
    :ensure t
    :config
    (yas-global-mode 1)
    (setq yas-snippet-dirs '(".config/emacs/snippets")))
    #+end_src


* Minibuffer (basically Vertico)

This customizes the way the Minibuffer works in Emacs.

Best Case Scenario: I'd like to make the =:= binding in Evil-mode behave like =M-x= in the sense that it automatically uses the minibuffer for completion (makes it a lot cleaner).

#+begin_src emacs-lisp
  (use-package vertico
    :ensure t
    :config
    (setq vertico-preselect 'first
	  vertico-count 10)
    (vertico-mode 1)
    (vertico-buffer-mode))

  (use-package marginalia
    :ensure t
    :config
    (marginalia-mode))

  (use-package orderless
    :ensure t
    :custom
    (completion-styles '(orderless basic))
    (completion-category-overrides '((file (styles basic partial-completion)))))

  (use-package consult
    :ensure t
    :config
    (setq completion-in-region-function 'consult-completion-in-region))
#+end_src


* RSS Feeds

I'll be using Elfeed as my RSS reader for news and tech updates.

#+begin_src emacs-lisp
  (use-package stripes :ensure t)
  (use-package elfeed :ensure t)
  (use-package elfeed-org :ensure t :after elfeed :config (elfeed-org))
#+end_src


* Other esoteric stuff

Stuff that is just here to get one task or a few tasks done, not worth going too deep into.

** Dyalog APL

I did try learning Dyalog APL for the APL Forge contest, and found it quite cool. Nice to have a minor mode (and sometime later, and input-mode) for it. Not in use currently

#+begin_src emacs-lisp :tangle not-init.el
  (use-package dyalog-mode
    :ensure t
    :config
    (defun org-babel-execute:dyalog (body params)
      (org-babel-execute:jupyter-apl body params))

    (defun org-babel-dyalog-initiate-session (&optional arg1 arg2)
      (org-babel-jupyter-apl-initiate-session &optional arg1 arg2))

    (setq org-babel-default-header-args:jupyter-apl '((:kernel . "dyalog_apl")
                                                      (:session . "*new*")
                                                      (:exports . "both")
                                                      (:eval . "never-export"))

          org-babel-default-header-args:dyalog '((:kernel . "dyalog_apl")
                                                 (:session . "*new*")
                                                 (:exports . "both")
                                                 (:eval . "never-export"))))
#+end_src


* NΛNO Emacs modules

This is the bit that was (more or less) entirely copy-pasted from Nicolas Rougier's repositories. These are what make Emacs look so incredibly clean. After yoinking them from the repos, I've made major changes to them in order to make them more compatible with my editing style and colour scheme.

For now, I'll be keeping all the Elisp in separate files in the =nano/= directory and ~require~-ing them here. Ideally I would like to include all Elisp in this file, but that might make this unreadable.

#+begin_src emacs-lisp
  (add-hook 'elpaca-after-init-hook
            (lambda ()
              (progn
                (require 'nano-modeline)
                (nano-modeline nil nil t)
                (require 'nano-vertico)
                (nano-vertico-mode)

                (require 'nano-splash)
                (require 'nano-calendar)
                (require 'nano-agenda)

                (require 'nano-read)
  	      (require 'nano-sidebar)

                (require 'nano-org)

                ;; (require 'nano-elfeed)
                (require 'nano-kill)
                (require 'nano-block))))
#+end_src
  
                
