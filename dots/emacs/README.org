#+title: Druhan's Emacs Configuration
#+author: Druhan Shah

#+startup: overview
#+property: header-args :tangle init.el
#+auto_tangle: t

This configuration started off heavily based off of [[https://github.com/rougier][Nicolas Rougier]]'s Emacs packages and ideas. I still have a dedicated =nano/= directory for configurations more or less entirely mooched off his excellent packages. This has now, however, grown into a monstrosity beyond singular attribution, having incorporated ideas and packages by other giants in the Emacs world such as Karthink, Minad, Prot, and Xenodium, and will continue to grow as I understand Emacs and my own working style better. The hope is that by the end it will have condensed into a semblance of order. This file is supposed to be somewhat sensibly structured after all.

This file is a literate configuration, which means all the code blocks in this Org file will be exported using Org-Babel's tangle feature into their corresponding config files on save. As a result, all the configuration necessary will be in this file as far as possible. Sometime in the future, a Table of Contents will be implemented to make navigating this document easier.

+Here's a screenshot of what this configuration looks like in action (this may or may not be slightly outdated):+


* Preambles 

The Early-Init file is executed before =init.el=, and hence is where we disable =package.el= in favour of Elpaca.

#+begin_src emacs-lisp :tangle early-init.el
  ;; Early-init file, executed before init.el when starting Emacs

  (setq package-enable-at-startup nil)
#+end_src


* Package Manager (Elpaca)

This codeblock is directly from the Elpaca repository's README. I have only added a final expression integrating Elpaca with ~use-package~.

There's apparently something to be done when Elpaca is used with Emacs on NixOS, but I'm yet to implement that just yet.

#+begin_src emacs-lisp
  (defvar elpaca-installer-version 0.11)
  (defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
  (defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
  (defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
  (defvar elpaca-order
    '(elpaca :repo "https://github.com/progfolio/elpaca.git"
             :ref nil :depth 1 :inherit ignore
             :files (:defaults "elpaca-test.el" (:exclude "extensions"))
             :build (:not elpaca--activate-package)))
  (let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
         (build (expand-file-name "elpaca/" elpaca-builds-directory))
         (order (cdr elpaca-order))
         (default-directory repo))
    (add-to-list 'load-path (if (file-exists-p build) build repo))
    (unless (file-exists-p repo)
      (make-directory repo t)
      (when (<= emacs-major-version 28) (require 'subr-x))
      (condition-case-unless-debug err
          (if-let* ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                    ((zerop
                      (apply #'call-process
                             `("git" nil ,buffer t "clone"
                               ,@(when-let* ((depth (plist-get order :depth)))
                                   (list
  				  (format "--depth=%d" depth)
  				  "--no-single-branch"))
                               ,(plist-get order :repo) ,repo))))
                    ((zerop (call-process "git" nil buffer t "checkout"
                                          (or (plist-get order :ref) "--"))))
                    (emacs (concat invocation-directory invocation-name))
                    ((zerop (call-process
                             emacs nil buffer nil "-Q" "-L" "." "--batch"
                             "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                    ((require 'elpaca))
                    ((elpaca-generate-autoloads "elpaca" repo)))
              (progn (message "%s" (buffer-string)) (kill-buffer buffer))
            (error "%s" (with-current-buffer buffer (buffer-string))))
        ((error) (warn "%s" err) (delete-directory repo 'recursive))))
    (unless (require 'elpaca-autoloads nil t)
      (require 'elpaca)
      (elpaca-generate-autoloads "elpaca" repo)
      (load "./elpaca-autoloads")))
  (add-hook 'after-init-hook #'elpaca-process-queues)
  (elpaca `(,@elpaca-order))
  (elpaca elpaca-use-package
    (elpaca-use-package-mode))
#+end_src


* Bits and bobs

This is a bunch of other niceties that I would like to have, since that would make configuration and usage a good bit easier.

- Garbage collector reduction for faster startup
- +Add all files in the =nano/= directory into the loading path+
- Auto-revert mode to automatically reload files changed on disk (might slow things down a /tiny/ bit)

#+begin_src emacs-lisp
  (setq gc-cons-threshold 63000000
        gc-cons-percentage 0.6)
  (global-auto-revert-mode)
#+end_src

** "Sane defaults"

This section deals with simple default values that I would like to have set by default for /my/ Emacs experience. These are by no means general statements on what should be the defaults.

#+begin_src emacs-lisp
  (setq inhibit-startup-screen t)
  (setq inhibit-startup-message t)
  (setq inhibit-startup-echo-area-message t)
  (setq initial-scratch-message nil)
  (setq initial-buffer-choice nil)

  (setq frame-title-format nil)
  (setq use-file-dialog nil)
  (setq use-dialog-box nil)
  (setq pop-up-windows nil)
  (setq indicate-empty-lines nil)
  (setq cursor-in-non-selected-windows nil)

  (setq initial-major-mode 'text-mode)
  (setq default-major-mode 'text-mode)
  (setq font-lock-maximum-decoration t)
  (setq auto-fill-mode nil)
  (setq fill-column 80)

  (setq-default cursor-type '(hbar .  2))
  (setq-default cursor-in-non-selected-windows nil)
  (setq blink-cursor-mode nil)

  (setq default-frame-alist
        (append (list
                 '(vertical-scroll-bars . nil)
                 '(scroll-bar-mode . -1)
                 '(tool-bar-lines . 0)
  	       '(tool-bar-position . left)
                 '(menu-bar-lines . 0))))

  (setq make-backup-files nil)

  (set-display-table-slot standard-display-table
                          'truncation
  			(make-glyph-code ?… 'font-lock-comment-face))
  (set-display-table-slot standard-display-table
                          'wrap
  			(make-glyph-code ?- 'font-lock-comment-face))
#+end_src


* UI and themes

** Colour Theme

While I do greatly enjoy Rougier's ~nano-theme~ and Prot's ~modus-~ and ~ef-themes~, I would like something more tailored to my taste while still attempting to retain ideas from their themes. I tried building on top of Prot's ~modus-operandi~ but it ended being a lot messier than I'd have liked (definitely a skill issue). I'm also tired of waiting for Rougier's ~nano-theme~ rewrite. I tried out the Stylix themes but waiting for them to load before doing anything in the init file was a pain. I'm trying out Prot's ~ef-themes~ now.

#+begin_src emacs-lisp
  (use-package ef-themes
    :ensure t
    :init
    (modus-themes-include-derivatives-mode)
    :config
    (setq modus-themes-mixed-fonts t
  	modus-themes-italic-constructs t
  	modus-themes-bold-constructs t
  	modus-themes-variable-pitch-ui t
  	modus-themes-prompts '(extrabold)
  	modus-themes-headings '((0 . (variable-pitch 1.5))
  				(1 . (variable-pitch 1.2))
  				(2 . (variable-pitch 1.2))
  				(agenda-date . (1.3))
  				(agenda-structure . (variable-pitch light 1.8))
  				(t . (variable-pitch 1.2))))
    (modus-themes-load-theme 'ef-eagle))
#+end_src

Of course it wouldn't be a personal config without some theme changes...

#+begin_src emacs-lisp
  (add-hook 'modus-themes-after-load-theme-hook
  	  (lambda ()
  	    (set-face-attribute 'vertical-border nil
  				:foreground (face-background 'default))
  	    (set-face-attribute 'window-divider nil
  				:foreground (face-background 'default))
  	    (set-face-attribute 'window-divider-last-pixel nil
  				:foreground (face-background 'default))
  	    (set-face-attribute 'window-divider-first-pixel nil
  				:foreground (face-background 'default))))
#+end_src

** UI niceties

Rougier's designs were instrumental in showing how important good spacing is. However, instead of going the barebones route and then having to fiddle with the window dividers, I'll be using Prot's =spacious-padding= package so that I can have a clear section in the code all for this.

#+begin_src emacs-lisp
  (use-package spacious-padding
    :ensure t
    :config
    (setq spacious-padding-widths
  	'( :internal-border-width 20
  	   :header-line-width 6
  	   :mode-line-width 0
  	   :custom-button-width 3
  	   :right-divider-width 20
  	   :scroll-bar-width 0
  	   :fringe-width 0))
    (spacious-padding-mode 1))
#+end_src

There's also pixel-perfect scrolling which really makes the emacs experience feel more modern.

#+begin_src emacs-lisp
  (use-package ultra-scroll
    :ensure t
    :init
    (setq scroll-conservatively 3
  	scroll-margin 0)
    :config
    (ultra-scroll-mode 1))
#+end_src


* Typography

This is all the stuff I need to improve typography when using Emacs. This includes coding ligatures, icons, and colour code rendering.

** Font setup

I'm using Prot's =fontaine= package to setup my default fonts, independent of Rougier's packages.

#+begin_src emacs-lisp
  (use-package fontaine
    :ensure t
    :config
    (setq fontaine-presets
  	'((default
  	   :default-family "Iosevka"
  	   :fixed-pitch-family "Iosevka"
  	   :variable-pitch-family "Inter"
  	   :mode-line-active-family "Inter"
  	   :mode-line-inactive-family "Inter"
  	   :header-line-family "Inter"

  	   :default-weight regular
  	   :bold-weight semi-bold
  	   :italic-slant italic

  	   :default-height 108
  	   :line-spacing 0.1)))
    (fontaine-set-preset 'default))
#+end_src

** Nice-to-haves

#+begin_src emacs-lisp
  (use-package ligature
    :ensure t
    :config
    (ligature-set-ligatures
     'prog-mode '("<---" "<--"  "<<-" "<-" "->" "-->" "--->" "<->" "<-->" "<--->"
  		"<---->" "<!--" "<==" "<===" "<=" "=>" "=>>" "==>" "===>" ">=" "<=>"
  		"<==>" "<===>" "<====>" "<!---" "<~~" "<~" "~>" "~~>" "::" ":::"
  		"==" "!=" "===" "!==" ":=" ":-" ":+" "<*" "<*>" "*>" "<|" "<|>" "|>"
  		"+:" "-:" "=:" "<******>" "++" "+++"))
    (global-ligature-mode t))

  (use-package nerd-icons
    :ensure t
    :if (display-graphic-p)
    :config
    (setq nerd-icons-font-family "Symbols Nerd Font"))

  (use-package nerd-icons-dired
    :ensure t
    :after nerd-icons
    :hook (dired-mode . nerd-icons-dired-mode))

  (use-package nerd-icons-ibuffer
    :ensure t
    :after nerd-icons
    :hook (ibuffer-mode . nerd-icons-ibuffer-mode)
    :config
    (setq nerd-icons-ibuffer-formats
  	'(("  "
  	   mark " "
  	   (icon 2 2) " "
  	   (name 24 24 :left :elide) "  "))))

  (use-package nerd-icons-corfu
    :ensure t
    :after nerd-icons
    :after corfu
    :config (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))

  (use-package nerd-icons-completion
    :ensure t
    :hook (marginalia-mode . nerd-icons-completion-marginalia-setup)
    :config
    (nerd-icons-completion-mode))

  (use-package colorful-mode
    :ensure t
    :config
    (global-colorful-mode))
#+end_src


* Vim Emulation

I use Evil-mode along with God-mode as an Evil state. I've tried Meow and didn't like it as much. I've tried God-mode as is and loved it, except that it lacked the pure Vim bindings. One issue that I'm still having is that =C-u= to scroll still doesn't work and I don't know why.

Note that there is a ~elpaca-wait~ call at the end because some customizations I use require Evil to be loaded.

#+begin_src emacs-lisp
  (use-package evil :ensure t
    :init
    (setq evil-want-keybinding nil
          evil-undo-system 'undo-redo
          evil-default-state 'normal
          evil-want-C-i-jump t
          evil-want-C-w-delete t
          evil-want-Y-yank-to-eol t
          evil-want-C-u-scroll t
          evil-want-C-d-scroll t)
    :config (evil-mode 1))

  (use-package evil-collection :ensure t :after evil
    :init (evil-collection-init))

  (use-package evil-god-state :ensure t :after evil
    :after evil
    :config
    (evil-define-key 'normal 'global "\\" 'evil-execute-in-god-state)
    (evil-define-key 'god 'global "escape" 'evil-god-state-bail))

  (use-package evil-surround :ensure t :after evil
    :config (global-evil-surround-mode 1))

  (use-package evil-commentary :ensure t :after evil
    :config (evil-commentary-mode))

  (use-package evil-numbers :ensure t :after evil
    :after evil
    :config
    (evil-define-key '(normal visual) 'global
      (kbd "C-a") 'evil-numbers/inc-at-pt
      (kbd "C-x") 'evil-numbers/dec-at-pt
      (kbd "g C-a") 'evil-numbers/inc-at-pt-incremental
      (kbd "g C-x") 'evil-numbers/dec-at-pt-incremental))
#+end_src


* GitHub, Copilot and other AI stuff

This sets up three major plugins: Magit (all hail), Copilot, and GPTel. Elpaca throws some weird errors if I don't include the transient =use-package= call.

#+begin_src emacs-lisp
  (use-package transient
    :ensure t)
  (use-package magit
    :ensure t)
#+end_src

Here, I set up the AI-based stuff like copilot (for completions) and GPTel (for other LLM and agent capabilities). I still need to get a handle on what GPTel can do for my particular use case.

#+begin_src emacs-lisp :tangle no
  (use-package copilot
    :vc (:url "https://github.com/copilot-emacs/copilot.el"
         :rev :newest
         :branch "main")
    :ensure t
    :hook (prog-mode . copilot-mode)
    :config
    (define-key copilot-completion-map (kbd "<tab>") 'copilot-accept-completion))

  (setq gemini-api-key (with-temp-buffer
  		       (insert-file-contents "~/.config/emacs/.gemini")
  		       (buffer-string)))

  (use-package gptel
    :ensure t
    :config
    (setq gptel-backend
  	(gptel-make-gemini "Gemini"
  			   :key gemini-api-key
  			   :stream t)
  	gptel-default-mode 'org-mode))
#+end_src


* Dired

This has some nice features that I would like when using the builtin Dired. The keybinds are to make it more like other Vim-like file managers, particularly Ranger (which is what I used earlier).

#+begin_src emacs-lisp
  (require 'dired)
  (require 'dired-x)
  (setq dired-listing-switches
        "-l --almost-all --human-readable --group-directories-first"
        dired-omit-files
        (concat dired-omit-files "\\|^\\..+$\\|^__pycache__$"))
  (put 'dired-find-alternate-file 'disabled nil)
  (add-hook 'dired-mode-hook 'dired-hide-details-mode)
  (add-hook 'dired-mode-hook 'dired-omit-mode)

  (define-key global-map (kbd "C-x C-d") 'dired-jump)
  (with-eval-after-load 'evil
    (evil-define-key 'normal dired-mode-map
      "g." 'dired-omit-mode
      "h" 'dired-jump
      "l" 'dired-find-file
      "L" (lambda () (interactive)
  	  (start-process "xdg" nil "xdg-open" (dired-get-file-for-visit)))
      "n" 'evil-search-next
      "N" 'evil-search-previous
      "o" 'dired-sort-toggle-or-edit
      "v" 'dired-toggle-marks
      "m" 'dired-mark
      "u" 'dired-unmark
      "c" 'dired-create-directory
      "t" 'dired-create-empty-file))
  #+end_src

I tried out =dirvish=, but I didn't like the jank without a custom setup, so I'm sticking to vanilla Dired.


* IBuffer

As much as I need some good buffer management tools, I don't like how IBuffer behaves particularly with evil. This is an attempt to make it that much better.

#+begin_src emacs-lisp
  (with-eval-after-load 'evil
    '(progn
       (evil-set-initial-state 'ibuffer-mode 'normal)
       (evil-define-key 'normal ibuffer-mode-map
         (kbd "v") 'ibuffer-toggle-marks
         (kbd "l") 'ibuffer-visit-buffer)))

  (setq ibuffer-saved-filter-groups
        '(("custom"
  	 ("Dotfiles" (filename . "dotfiles/"))
  	 ("Org files" (mode . org-mode))
  	 ("Code" (derived-mode . prog-mode))
  	 ("Text files" (and (mode . text-mode)
  			    (not (starred-name))))
  	 ("Dired" (mode . dired-mode))
  	 ("Magit" (name . "\*magit"))
  	 ("Auxiliary buffers" (starred-name)))))
  (setq ibuffer-show-empty-filter-groups nil
        ibuffer-use-header-line nil
        ibuffer-display-summary nil
        ibuffer-eliding-string "…"
        ibuffer-marked-char ?\
        ibuffer-modified-char ?\
        ibuffer-read-only-char ?\
        ibuffer-deletion-char ?\)
#+end_src

The next snippet is all about making the IBuffer buffer that much prettier. This is also pretty much mooched off of Nicolas Rougier's NANO-sidebar package.

#+begin_src emacs-lisp
  (defun ibuffer-advice (_format)
    (with-current-buffer "*Ibuffer*"
      (save-excursion
      (let ((inhibit-read-only t))

        ;; Remove header and insert ours
        (goto-char (point-min))
        (search-forward " \n" nil t)
        (search-forward " \n" nil t)
        (delete-region 1 (point))
        (goto-char (point-min))
        (insert (concat
                 (propertize "\n" 'face '(:height 0.8))
                 (propertize "Buffer List"
                             'face `(org-document-title variable-pitch))
                 (propertize " "  'display `(raise -0.35))
                 "\n"))
        (insert "")

        ;; Transform titles
        (goto-char (point-min))
        (while (re-search-forward "\\[ \\(.*\\) \\]" nil t)
          (let* ((title (match-string 0))
                 (property (get-text-property 0 'ibuffer-filter-group-name title)))
            (replace-match "\n")
            (insert (concat
                     (propertize
                      (substring title 2 -2)
                      'ibuffer-filter-group-name property
  		      'face '(org-level-2 variable-pitch))
                     "\n"))))))))

  (defun ibuffer-setup ()
    (ibuffer-switch-to-saved-filter-groups "custom")
    (ibuffer-auto-mode 1))

  (advice-add 'ibuffer-update-title-and-summary :after #'ibuffer-advice)
  (add-hook 'ibuffer-mode-hook #'ibuffer-setup)
  (define-key global-map (kbd "C-x C-b") 'ibuffer)
#+end_src


* Calc

A dedicated LaTeX mode wasn't enough, now we actually have to do math. The horror!
Jokes aside, I've seen the power of Emacs' built in calculator and I'm sold. I'm also looking forward to the release of Karthink's work on using latex in calc first class.

*NB:* I was going to add casual to this, but I'm considering abandoning it for the built-in [[Which-Key]]

#+begin_src emacs-lisp
#+end_src


* Which-Key

It occurs to me that I am not an Emacs dictionary. Who'd have thunk?

#+begin_src emacs-lisp
  (which-key-mode 1)
  (which-key-setup-side-window-bottom)
  (which-key-enable-god-mode-support)
#+end_src


* Regex builder

I'm starting to find too many insanely cool builtin features in Emacs. The Interactive Regex Builder is another in that huge list. Also, Karthink has a fantastic blog post on using the regex builder and tying it with using =query-replace-regexp= as a better, more visual version of vim's =:%s/= replacement.

#+begin_src emacs-lisp
  (require 're-builder)
  (setq reb-re-syntax 'string)

  (defvar drs/re-builder-positions nil
    "Store point and region bounds before calling `re-builder'.")
  (advice-add 're-builder
  	    :before
  	    (defun my/re-builder-save-state (&rest _)
  	      "Save into `my/re-builder-positions' the point and region
    positions before calling `re-builder'."
  	      (setq my/re-builder-positions
  		    (cons (point)
  			  (when (region-active-p)
  			    (list (region-beginning)
  				  (region-end)))))))

  (defun reb-replace-regexp (&optional delimited)
    "Run `query-replace-regexp' with the contents of `re-builder'.
  With non-nil optional argument DELIMITED, only replace matches
  surrounded by word boundaries."
    (interactive "P")
    (reb-update-regexp)
    (let* ((re (reb-target-value 'reb-regexp))
           (replacement (query-replace-read-to
  		       re
  		       (concat "Query replace"
  			       (if current-prefix-arg
                                     (if (eq current-prefix-arg '-) " backward" " word")
                                   "")
  			       " regexp"
  			       (if (with-selected-window reb-target-window
                                       (region-active-p)) " in region" ""))
  		       t))
           (pnt (car drs/re-builder-positions))
           (beg (cadr drs/re-builder-positions))
           (end (caddr drs/re-builder-positions)))
      (with-selected-window reb-target-window
        (goto-char pnt)
        (setq drs/re-builder-positions nil)
        (reb-quit)
        (query-replace-regexp re replacement delimited beg end))))


  (define-key reb-mode-map (kbd "RET") #'reb-replace-regexp)
  (define-key reb-lisp-mode-map (kbd "RET") #'reb-replace-regexp)
  ;; (define-key global-map (kbd "C-s") #'re-builder)
#+end_src


* PDF Tools and ePub reading

This section initially used PDF-Tools and =nov.el= for document reading (despite the jank from =nov.el=), but I'm now considering switching to Divya Ranjan's package =emacs-reader= which relies on MuPDF which I'm a big fan of. Looks quite promisnig!

On first try it's beautiful! The only gripe I have is the lack of annotations and theming, both of which (especially in my case) are only minor nitpicks. There's also another issue of not being able to find =render-core.so= which I broke my head over for too long, but it ended up being a NixOS issue since compiling the C libraries in =emacs-reader= required the MuPDF libraries which weren't globally visible.

There's still some breakages, but I'll get around to fixing them eventually, since I have Zathura for documents at the moment.

#+begin_src emacs-lisp
  (use-package reader
    :ensure (:type git :host codeberg :repo "divyaranjan/emacs-reader"
  	   :files ("*.el" "render-core.so")
  	   :pre-build ("make" "all")))
#+end_src


* Completions and Spellchecking

** Completions at point

I'm (not really) using Corfu at the moment. Haven't tried out other completion frameworks

#+begin_src emacs-lisp
  (use-package corfu
    :ensure t
    :config
    (setq corfu-auto t)
    (global-corfu-mode))
#+end_src

** Spell checking

For spellchecking, I did try out jinx, but never ended up actually using it. Apparently Grammarly's Language Server borked itself. Then I switched to the OSS variant called LanguageTool (a maintained fork called LTeX+), it was bugged out of its tiny little mind. I've no updates on this end so far, but I'm willing to try out jinx again.

** Syntax checking and diagnostics

For syntax checking, I'm starting to use flymake-mode, which should integrate decently with the version of ~nano-modeline~ that I have.
I'm using custom fringe bitmaps to indicate the locations of errors, warnings and notes.

#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook #'flymake-mode)
  (with-eval-after-load 'evil
    (evil-define-key 'normal flymake-mode-map
      "]d" 'flymake-goto-next-error
      "[d" 'flymake-goto-prev-error))
  (setq flymake-start-on-flymake-mode t
        flymake-indicator-type 'fringes)
#+end_src


* Eshell and Eat

I'm pretty much set on using =emacs-eat= as a terminal with Eshell. I just need to figure out how to make it look nice, and how to personalize it to my usage. One superpower I read about on Reddit was the usage of snippets in the terminal with YASnippet.

#+begin_src emacs-lisp
  (use-package eat
    :ensure t)
#+end_src

Some eshell niceties are to be expected :P

#+begin_src emacs-lisp
  (setq eshell-prompt-function
  	  (lambda ()
  	    (concat
  	     (propertize "\n" 'face `(:foreground ,(face-background 'default)
  				      :extend t
  				      :underline ,(face-foreground 'default)))
  	     (propertize " " 'face `(:height 1.6
  				     :weight 'bold))
  	     (propertize "" 'face `(:foreground "green"
  				     :weight 'bold))
  	     (propertize " " 'face `(:foreground ,(face-foreground 'default)
  				     :extend t)))))

  (define-key global-map (kbd "C-x C-s") 'eshell)
#+end_src


* Org Mode and LaTeX

All hail the OrgMode system! Lots of very helpful modules have been used here, and this is by far the largest section in my config.

** Baseline stuff

First, since we're using ~org-cdlatex-mode~, we need to also install auctex, which might cause some issues.

#+begin_src emacs-lisp
  (use-package auctex
    :ensure (:repo "https://git.savannah.gnu.org/git/auctex.git"
  	   :branch "main"
  	   :pre-build (("make" "elpa"))
  	   :build (:not elpaca--compile-info)
  	   :files ("*.el" "doc/*.info*" "etc" "images" "latex" "style")
  	   :version (lambda (_) (require 'auctex) AUCTeX-version))
    :config
    (setq TeX-view-program-selection
  	'((output-dvi "xdvi") (output-pdf "Zathura") (output-html "xdg-open"))))

  (use-package cdlatex
    :ensure t)
#+end_src

Now we can get back to org.

#+begin_src emacs-lisp
  (cl-pushnew 'org elpaca-ignored-dependencies)

  (use-package org
    :ensure nil
    :hook (org-mode . visual-line-mode)
    :hook (org-mode . mixed-pitch-mode)
    :hook (org-mode . org-display-inline-images)
    :hook (org-mode . org-cdlatex-mode)
    :hook (org-mode . org-indent-mode)
    :config
    (setq org-ellipsis " "
  	org-fontify-quote-and-verse-blocks t
          org-hide-emphasis-markers t
          org-hide-leading-stars nil
  	org-cycle-separator-lines 2
          org-pretty-entities t
          org-pretty-entities-include-sub-superscripts nil
          org-use-sub-superscripts t
          org-format-latex-options (plist-put org-format-latex-options :scale 0.75)
          org-latex-src-block-backend 'listings
  	org-latex-packages-alist '(("" "amsmath" t)
  				   ("" "amssymb" t)
  				   ("" "amsfonts" t)
  				   ("" "amsthm" t)
  				   ("" "mathtools" t)
  				   ("" "braket" t)
  				   ("" "physics" t)
  				   ("" "xcolor" t)
  				   ("" "tikz" t)
  				   ("" "tikz-cd" t))
  	org-todo-keywords '((sequence "TODO" "DOING" "|" "DONE")
  			    (sequence "HOLD" "|" "NOPE"))
  	org-priority-highest 0
          org-priority-lowest 9
  	org-priority-default 5
  	org-agenda-files '("~/notes/agenda/habits.org"
  			   "~/notes/agenda/leisure.org"
  			   "~/notes/agenda/refile.org"
  			   "~/notes/agenda/work.org")
  	org-hidden-keywords '(title subtitle author date)
  	org-src-window-setup 'current-window)
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (latex . t)
       (python . t)))
    (setf (cdr (assoc 'file org-link-frame-setup)) 'find-file))
#+end_src

** Org-Roam

I liked the idea behind Org-Roam. I like the project itself, I really do! Ultimately I think Zettelkasten isn't for me, and I'm better off just using interconnected notes in multiple subdirectories instead of having a zero-depth colossal notes directory.

** Jupyter and other Babel shenanigans

Babel is a module of Org mode that deals with other programming languages and how they integrate with Org. These integrations include "tangling" (bundling all codeblocks in an org file into an actual code file), and running in the file itself.

This section used to include stuff about exporting and editing Jupyter notebooks, but I've abandoned that now. I'll likely be switching to marimo whenever interactivity is a requirement.

*** Auto tangling

#+begin_src emacs-lisp
  (use-package org-auto-tangle
    :ensure t
    :after org
    :hook (org-mode . org-auto-tangle-mode))
#+end_src

** Citation management

Zotero is a gem, but it's a little messy to integrate into my Org-LaTeX documents, but I've heard of Citar which seems to make it /schmooth/.

#+begin_src emacs-lisp
  (use-package citar
    :ensure t
    :after nerd-icons org
    :custom
    (org-cite-global-bibliography '("~/research/bibliography/NLP-Stuff.bib"
  				  "~/research/bibliography/Math-Stuff.bib"
  				  "~/research/bibliography/Other-Fun-Stuff.bib"))
    (org-cite-insert-processor 'citar)
    (org-cite-follow-processor 'citar)
    (org-cite-activate-processor 'citar)
    (citar-bibliography org-cite-global-bibliography)
    :bind
    (:map org-mode-map :package org ("C-c i" . #'org-cite-insert))
    :config
    (defvar citar-indicator-notes-icons
      (citar-indicator-create
       :symbol (nerd-icons-mdicon
  	      "nf-md-notebook"
  	      :face 'nerd-icons-blue
  	      :v-adjust -0.3)
       :function #'citar-has-notes
       :padding "  "
       :tag "has:notes"))

    (defvar citar-indicator-links-icons
      (citar-indicator-create
       :symbol (nerd-icons-octicon
                "nf-oct-link"
                :face 'nerd-icons-orange
                :v-adjust -0.1)
       :function #'citar-has-links
       :padding "  "
       :tag "has:links"))

    (defvar citar-indicator-files-icons
      (citar-indicator-create
       :symbol (nerd-icons-faicon
                "nf-fa-file"
                :face 'nerd-icons-green
                :v-adjust -0.1)
       :function #'citar-has-files
       :padding "  "
       :tag "has:files"))
    (setq citar-indicators
  	(list citar-indicator-files-icons
  	      citar-indicator-notes-icons
  	      citar-indicator-links-icons)))

#+end_src

** UI Stuff

These are some nice-to-haves that make Org files look good in Emacs.

#+begin_src emacs-lisp
  (use-package org-autolist
    :ensure t
    :after org
    :hook (org-mode . org-autolist-mode))

  (use-package mixed-pitch
    :ensure t
    :hook (org-mode . mixed-pitch-mode))
#+end_src

The next bit is all about the =org-modern= package by minad (Daniel Mendler). I was earlier using the modified source code of the package as =nano-org= thinking I could nano-ify the whole thing, but in hindsight it was far more sensible to just customize some variables.

#+begin_src emacs-lisp
  (use-package org-modern
    :ensure t
    :after org
    :custom
    (org-modern-star 'fold)
    (org-modern-hide-stars t)
    (org-modern-timestamp '(" %^b %d " . " %H%M "))
    (org-modern-todo-faces `(("TODO" . (:foreground ,(modus-themes-get-color-value 'red)
  				      :height 95
  				      :box (1 . 2)
  				      :overline ,(modus-themes-get-color-value 'bg-main)))
  			   ("DOING" . (:foreground ,(modus-themes-get-color-value 'yellow)
  				       :height 95
  				       :box (1 . 2)
  				       :overline ,(modus-themes-get-color-value 'bg-main)))
  			   ("DONE" . (:foreground ,(modus-themes-get-color-value 'green)
  				      :height 95
  				      :box (1 . 2)
  				      :overline ,(modus-themes-get-color-value 'bg-main)))
  			   ("HOLD" . (:foreground ,(modus-themes-get-color-value 'fg-alt)
  				      :height 95
  				      :box (1 . 2)
  				      :overline ,(modus-themes-get-color-value 'bg-main)))
  			   ("NOPE" . (:foreground ,(modus-themes-get-color-value 'fg-dim)
  				      :height 95
  				      :box (1 . 2)
  				      :overline ,(modus-themes-get-color-value 'bg-main)))))
    :custom-face
    (org-modern-label
     ((t (:family "Iosevka"
  	:height 95))))
    (org-modern-date-active
     ((t (:inherit (org-modern-label)
  	:foreground ,(modus-themes-get-color-value 'bg-main)
  	:background ,(modus-themes-get-color-value 'blue)
  	:overline ,(modus-themes-get-color-value 'bg-main)
  	:box (:color ,(modus-themes-get-color-value 'blue)
  	      :line-width (1 . 2))))))
    (org-modern-time-active
     ((t (:inherit (org-modern-label)
  	:foreground ,(modus-themes-get-color-value 'blue)
  	:background ,(modus-themes-get-color-value 'bg-main)
  	:overline ,(modus-themes-get-color-value 'bg-main)
  	:box (:line-width (1 . 2))))))
    (org-modern-date-inactive
     ((t (:inherit (org-modern-label)
  	:foreground ,(modus-themes-get-color-value 'bg-main)
  	:background ,(modus-themes-get-color-value 'fg-dim)
  	:overline ,(modus-themes-get-color-value 'bg-main)
  	:box (:color ,(modus-themes-get-color-value 'fg-dim)
  	      :line-width (1 . 2))))))
    (org-modern-time-inactive
     ((t (:inherit (org-modern-label)
  	:foreground ,(modus-themes-get-color-value 'fg-dim)
  	:background ,(modus-themes-get-color-value 'bg-main)
  	:overline ,(modus-themes-get-color-value 'bg-main)
  	:box (:line-width (1 . 2))))))
    :config
    (global-org-modern-mode))
#+end_src

I'd also like some changes in the faces of the headers themselves. I don't like how colourful they are since it feels distracting.

#+begin_src emacs-lisp
  (add-hook 'modus-themes-after-load-theme-hook
  	  (lambda ()
  	    (with-eval-after-load 'org-faces
  	    (set-face-attribute 'org-level-1 nil
  				:foreground (modus-themes-get-color-value 'fg-main))
  	    (set-face-attribute 'org-level-2 nil
  				:foreground (modus-themes-get-color-value 'fg-main))
  	    (set-face-attribute 'org-level-3 nil
  				:foreground (modus-themes-get-color-value 'fg-main))
  	    (set-face-attribute 'org-level-4 nil
  				:foreground (modus-themes-get-color-value 'fg-main))
  	    (set-face-attribute 'org-level-5 nil
  				:foreground (modus-themes-get-color-value 'fg-main))
  	    (set-face-attribute 'org-level-6 nil
  				:foreground (modus-themes-get-color-value 'fg-main)))))
#+end_src

*** Markdown

Markdown is surprisingly similar to Org notation, but the rendering isn't nearly as good. I'll be fixing that here (as much as I can). Some changes are in the [[Face Overrides]] subsection of the themes section.

There was a neat little toggle for the plaintext vs rendered text mode, but I use it infrequently enough that a simple =M-x= should suffice.

#+begin_src emacs-lisp
  (use-package markdown-mode
    :ensure t)

  (add-hook 'markdown-mode-hook #'mixed-pitch-mode)
  (add-hook 'markdown-view-mode-hook #'mixed-pitch-mode)
#+end_src

** Bonuses

Org-contrib is a godsend! I'm a little disappointed there's a lot of conflicting information about it (almost certainly a skill issue btw).

#+begin_src emacs-lisp
  (use-package org-contrib
    :ensure t
    :config
    (require 'ox-extra)
    (ox-extras-activate '(latex-header-blocks ignore-headlines)))
#+end_src


* Treesitter and LSP

This feels more comfortable and simultaneously not. I need to get more comfortable with both of these as they are implemented in Emacs. There's also issues about being able to use LSPs on NixOS which I haven't yet worked on.

#+begin_src emacs-lisp
  (use-package treesit-auto
    :ensure t
    :custom
    (treesit-auto-install 'prompt)
    :config
    (treesit-auto-add-to-auto-mode-alist 'all)
    (global-treesit-auto-mode))

  (setq treesit-font-lock-level 4)

  (use-package exec-path-from-shell
    :ensure t
    :config
    (exec-path-from-shell-initialize))

  (with-eval-after-load 'evil
    (evil-define-key 'normal eglot-mode-map
      (kbd "g Q") 'eglot-format-buffer
      (kbd "g R") 'eglot-rename
      (kbd "g C") 'eglot-code-actions))
#+end_src

Some more nice-to-haves :P

#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook #'electric-pair-mode)

  (use-package highlight-indent-guides
    :ensure t
    :hook (prog-mode . highlight-indent-guides-mode)
    :config
    (highlight-indent-guides-auto-set-faces)
    (setq highlight-indent-guides-method 'character
  	highlight-indent-guides-auto-enabled t
  	highlight-indent-guides-responsive 'top
  	highlight-indent-guides-delay 0))
    #+end_src


* Snippets

I'm starting to get the idea that snippets are going to be very useful. (Who'd have thought?)
I'm using good old =yasnippet= for this.

#+begin_src emacs-lisp
  (use-package yasnippet
    :ensure t
    :config
    (yas-global-mode 1)
    (setq yas-snippet-dirs '(".config/emacs/snippets")))
#+end_src


* Minibuffer

This customizes the way the Minibuffer works in Emacs.

Dream feature (which is honestly impossible): I'd like Evil to mimic the use of native features in completion, in the sense that =:= ends up behaving like =M-x= in the way it pops up vertico with completions. Similarly with =/= and =consult-line= and so on.

#+begin_src emacs-lisp
  (use-package vertico
    :ensure t
    :config
    (vertico-mode 1)
    (setq vertico-preselect 'first
  	vertico-count 10
  	vertico-resize nil))

  (use-package marginalia
    :ensure t
    :config
    (marginalia-mode))

  (use-package orderless
    :ensure t
    :custom
    (completion-styles '(orderless basic))
    (completion-category-overrides '((file (styles basic partial-completion)))))

  (use-package consult
    :ensure t
    :bind (("C-x b" . consult-buffer)))
#+end_src


* Mode Line

I'm moving from Rougier's =nano-modeline= and skipping other modeline packages like =doom-modeline= and others to write my custom modeline inspired by =nano-modeline=, since Rougier's package contains so much that I don't use myself and doesn't customize some things I need. I still would prefer a headerline instead of a modeline, similar to Nano Emacs.

** Faces

The shenaniganery that goes on because I'm using stylix is genuinely painful. I really wish the theme could be loaded at the very beginning always. Oh well, here's a workaround for a NANO-modeline-style modeline.

#+begin_src emacs-lisp
  (add-hook 'modus-themes-after-load-theme-hook
  	  (lambda ()
  	    (custom-set-faces
  	     `(header-line ((t ( :foreground ,(modus-themes-get-color-value 'fg-mode-line-active)
  				 :background ,(modus-themes-get-color-value 'bg-mode-line-active)
  				 :inherit nil))))
  	     `(header-line-weak ((t ( :foreground ,(modus-themes-get-color-value 'fg-dim)
  				      :inherit header-line))))
  	     `(mode-line ((t ( :foreground ,(modus-themes-get-color-value 'bg-main)
  			       :background ,(modus-themes-get-color-value 'bg-main)
  			       :underline ,(modus-themes-get-color-value 'border)
  			       :box nil
  			       :height 0.1))))
  	     `(mode-line-active ((t ( :foreground ,(modus-themes-get-color-value 'bg-main)
  				      :background ,(modus-themes-get-color-value 'bg-main)
  				      :underline ,(modus-themes-get-color-value 'border)
  				      :box nil
  				      :height 0.1))))
  	     `(mode-line-inactive ((t ( :foreground ,(modus-themes-get-color-value 'bg-main)
  					:background ,(modus-themes-get-color-value 'bg-main)
  					:underline ,(modus-themes-get-color-value 'border)
  					:box nil
  					:height 0.1)))))))
#+end_src

** Modules

I'm all for modularizing the components. Since I'm looking for a pretty chill modeline I don't see this section blowing up too much (famous last words).

#+begin_src emacs-lisp
  (defun mode-line-component-title ()
    "Return the title of the buffer."
    `(:eval (propertize "%b" 'face '(:inherit bold))))
#+end_src

** Formats

For now I'm just working on the default format that'll apply to all buffers. Eventually I'd like custom modelines based on the major mode.

#+begin_src emacs-lisp
  (defun drs-mode-line-format-default ()
    "Default modeline format for `prog-mode' and `text-mode'."
    (list
     " "
     (mode-line-component-title)))

  (defun drs-mode-line-format-nothing ()
    "Modeline format that just makes a line to separate the echo area."
    "")
#+end_src

** Enabling the modeline

#+begin_src emacs-lisp
  (setq-default header-line-format (drs-mode-line-format-default))
  (setq-default mode-line-format (drs-mode-line-format-nothing))
#+end_src


* Music and Media

** Music player

I'm really picking from all the greats here; Xenodium (Álvaro) has a fantastic-looking package called Ready-Player which I'll be using to play my music locally.

#+begin_src emacs-lisp
  (use-package ready-player
    :ensure t
    :after nerd-icons
    :custom-face
    (info-title-1 ((t (:inherit 'variable-pitch :weight bold :height 1.25))))
    (info-title-2 ((t (:inherit 'variable-pitch :weight bold :height 1.4))))
    :config
    (setq ready-player-my-media-collection-location "~/Music")
    (setq ready-player-open-externally-icon (nerd-icons-octicon "nf-oct-link_external")
  	ready-player-open-my-media-collection-icon (nerd-icons-mdicon "nf-md-home")
  	ready-player-shuffle-icon (nerd-icons-mdicon "nf-md-shuffle")
  	ready-player-repeat-icon (nerd-icons-mdicon "nf-md-repeat")
  	ready-player-autoplay-icon (nerd-icons-mdicon "nf-md-refresh_auto")
  	ready-player-search-icon (nerd-icons-octicon "nf-oct-search")
  	ready-player-help-icon (nerd-icons-mdicon "nf-md-help")
  	ready-player-previous-icon (nerd-icons-mdicon "nf-md-skip_previous")
  	ready-player-next-icon (nerd-icons-mdicon "nf-md-skip_next"))
    ;; Redefining a function cos the message exceeds the echo area
    (defun ready-player--make-time-progress-bar (progress total)
      "Make a progress bar with PROGRESS out of TOTAL, aligned with frame width.
  For example:
  00:00 ------ 00:30 ------ 01:00"
      (setq progress (round progress))
      (setq total (round total))
      (let* ((start-label "00:00")
             (label (ready-player--format-time progress))
             (total-label (ready-player--format-time total))
             (reserved-width (+ (length start-label) 1   ; "00:00 " start
                                1 (length label) 1       ; " 00:30 " current
                                1 (length total-label) 1)) ; " 01:00" end
             (bar-width (- (frame-width) reserved-width))
             (percentage (/ (* progress 1.0) total))
             (left-bars (round (* percentage bar-width)))
             (right-bars (- bar-width left-bars)))
        (concat start-label " "
                (make-string left-bars ?┄)
                " " label " "
                (make-string right-bars ?┄)
                " " total-label)))
    (ready-player-mode +1))
#+end_src

** RSS Feeds

I was using Elfeed as my RSS feed, but I don't use it very often so I'm considering trying it again a while later.


* Other esoteric stuff

I had packages for Dyalog APL, Lean4 and GhostText here but I don't seem to use them at all so they're getting the boot.

** Nix

Now that I'm using NixOS, I'm editing a lot of =.nix= files, which need their own major mode and LSP.

#+begin_src emacs-lisp
  (use-package nix-mode
    :ensure t
    :mode "\\.nix\\'")
#+end_src

